<!--
====================================================================
Version 74
CONFIGURATION RAPIDE (à modifier en haut du fichier)
- homeHeaderDefaultByLang : texte court dans la banderole AVANT le choix
  (ex. 'Bienvenue' / 'Welcome' / 'Välkommen' OU 'Questionnaire' / 'Frågeformulär')
- homeHeaderIntroLinesByLang : 2 lignes d’intro affichées dans la banderole (accueil)
- availableLangsByForm : langues disponibles par ID de questionnaire (empêche "Continuer" si non dispo)
- disabledForms : IDs des questionnaires pas encore prêts (seront affichés "(indisponible)")
- formLabelsByLang : libellés des questionnaires dans la liste (si votre code ne les définit pas déjà)
- introByFormOverrides : texte d’intro (page 2) spécifique par formulaire et langue (écrase le générique)
- messagesInterfaceOverrides : petites clés i18n à surcharger (ex. notAvailableLang, only)
- APP_VERSION_OVERRIDE : pour forcer la version affichée sans éditer APP.version plus bas (optionnel)
- Il existe deux banques de questions :
    1. questionsBank : version complète, utilisée en routine (DSM, Sommeil, etc.).
    2. questionsBankShort (ou Intro) : version réduite, utilisée uniquement pour des tests ou des démonstrations.
   Le programme charge l’une ou l’autre en fonction du mode choisi (standard vs test).
COMMENT MODIFIER :
- Changez simplement les valeurs dans les objets JS ci-dessous (entre <script>
window.__validationLock=false;

<!-- ===== PRELUDE (unique, défini très tôt) — VERSION RECALÉE POUR dsm74 (Q4 ajoutée) ===== -->
<!DOCTYPE html>

<html lang="sv">
<script>
// Libellés d’échelles (sv)
const SCALE_LABELS = {
  sv: {
    numeric : ["aldrig","ibland","ofta","mycket ofta","alltid"],
    verbal1 : ["inte alls","kanske","lite","ganska mycket","mycket"],
    verbal2 : ["dålig","rättvis","bra","mycket bra","utmärkt"],
    helpPrefix: "Välj 1–5"
  }
};
</script>
<head>
<script>
// === NEURO START FIX ===
// Make "Neurologi" the active, available form in Svenska and disable DSM-5.
(function(){
  var NEURO_KEYS = ["Neurologi","NEUROLOGIE","Neurology","NEURO"];
  var LANG = "Svenska";
  function ensure(obj, k, v){ try{ if(!obj[k]) obj[k]=v; }catch(_){ } }
  document.addEventListener('DOMContentLoaded', function(){
    try{
      // Current form
      window.currentForm = "Neurologi";
      // Make Neurologi available in Svenska
      window.AVAILABLE_LANGS_BY_FORM = window.AVAILABLE_LANGS_BY_FORM || {};
      NEURO_KEYS.forEach(function(k){ window.AVAILABLE_LANGS_BY_FORM[k] = [LANG]; });
      window.availableLangsByForm = window.AVAILABLE_LANGS_BY_FORM;

      // Disable DSM forms
      try{
        var dis = (window.disabledForms || []);
        if (Array.isArray(dis)){
          if (dis.indexOf("DSM")===-1) dis.push("DSM");
          if (dis.indexOf("DSM-5")===-1) dis.push("DSM-5");
          // remove Neurologi from disabled
          ["Neurologi","NEUROLOGIE","Neurology","NEURO"].forEach(function(k){
            var i = dis.indexOf(k); if (i>-1) dis.splice(i,1);
          });
        } else {
          window.disabledForms = ["DSM","DSM-5"];
        }
      }catch(_){ window.disabledForms = ["DSM","DSM-5"]; }

      // Force selects
      var fSel = document.getElementById("questionnaireSelect") || document.getElementById("formSelect");
      if (fSel){
        // Try to select the option whose text/value equals one of NEURO_KEYS
        var found = false;
        for (var i=0;i<fSel.options.length;i++){
          var opt = fSel.options[i];
          if (!opt) continue;
          var v = (opt.value||"").trim();
          var t = (opt.text||"").trim();
          if (NEURO_KEYS.indexOf(v)>-1 || NEURO_KEYS.indexOf(t)>-1){
            fSel.selectedIndex = i;
            found = true;
            break;
          }
        }
        if (!found){ fSel.value = "Neurologi"; }
      }
      var lSel = document.getElementById("languageSelect") || document.getElementById("langSelect");
      if (lSel){
        // Select Svenska
        for (var j=0;j<lSel.options.length;j++){
          var op = lSel.options[j];
          if ((op.value||"") === "Svenska" || (op.text||"") === "Svenska"){
            lSel.selectedIndex = j; break;
          }
        }
      }

      // If there is a function that validates availability, override it for Neurologi+Svenska
      window.isFormLanguageAvailable = (function(orig){
        return function(form, lang){
          try{
            if (NEURO_KEYS.indexOf(form)>-1 && (lang==="Svenska" || lang==="sv" || lang==="SV")){
              return true;
            }
          }catch(_){}
          return orig ? orig.apply(this, arguments) : true;
        };
      })(window.isFormLanguageAvailable);

      // Hide any warning about "Inte tillgängligt..."
      var warn = document.querySelector(".not-available, .warn, .warning, .text-danger");
      if (warn) { try{ warn.style.display = "none"; }catch(_){} }

    }catch(_){}
  });
})();
// === END NEURO START FIX ===
</script>
<script>
var verbal1 = [19, 30, 45, 47, 52, 26];
</script>
<script>

</script>
<script>

</script>
<script>

</script>

<script>
// === AUTO-INJECTED (Neurologi – 18 sektioner) ===
window.SECTIONS_SKIP = [3, 5, 11];

window.MIXED_QUESTIONS = new Set([ 20]);

window.getScaleTypeForQuestion = function(qIndex){
  if (window.VERBAL2_SET && window.VERBAL2_SET.has(qIndex)) return "verbal2";
  if (window.VERBAL1_SET && window.VERBAL1_SET.has(qIndex)) return "verbal1";
  return "numeric";
};
</script>
<meta charset="utf-8"/>
<title>Questionnaire</title>
<style>
/* Softer spacing for the intro page */
#introScreen #introText { line-height: 1.75; }
#introScreen #introText p { margin: 8px 0; }
</style>
<script>
// Turn each intro line into its own paragraph for clearer spacing
(function(){
  document.addEventListener('DOMContentLoaded', function(){
    try{
      var box = document.getElementById('introText');
      if (!box) return;
      // Only transform once
      if (box.__spacedApplied) return; box.__spacedApplied = true;
      var raw = box.textContent || '';
      var lines = raw.split(/\r?\n/).map(function(s){ return s.trim(); }).filter(Boolean);
      if (!lines.length) return;
      // Build paragraph nodes
      var frag = document.createDocumentFragment();
      lines.forEach(function(line){
        var p = document.createElement('p');
        p.textContent = line;
        frag.appendChild(p);
      });
      // Replace content
      while (box.firstChild) box.removeChild(box.firstChild);
      box.appendChild(frag);
    }catch(_){}
  });
})();
</script>
</head>
<body>
<!-- -------------------
     BLOC DE VALIDITÉ — NOM DE FICHIER + PARAMÈTRES DE LIEN + ADMIN

     ▶ Choix de validité au moment d'envoyer le lien :
        - ?vdays=5          → X jours à partir de la 1ʳᵉ ouverture (plus sûr)
        - ?vdate=YYYY-MM-DD → date précise (ex. 2025-09-25)
        - ?vunlim=1         → illimité
        - ?vlabel=off       → cache la bannière

     ▶ Fallback par NOM DE FICHIER (si aucun paramètre) :
        dsm60_sv_3days.html, dsm60_sv_10d.html
        dsm60_sv_uid-Jean_6days.html  (clé séparée pour "Jean")
        dsm60_sv_7days_v2.html        (campagne v2)
        (par défaut, si rien trouvé : 3 jours)

     ▶ ADMIN / ÉDITION ILLIMITÉE (toi) :
        - Au 1er accès, un prompt demande le code : tape seulement les
          premières lettres (ex. "swe…") → si ça correspond, tu es admin.
        - Mémo admin stocké dans localStorage de CET appareil.
        - Pour l’activer sans prompt : ?setadmin=1
        - Pour le désactiver : ?clearadmin=1
        - Bypass ponctuel : ?vadmin=TONCODE (ex. swedsleep25)
        - Illimité AUTO si ouverture en local (file://) ou localhost.

     ▶ OPTION : date fixe ABSOLUE (dans le code)
        Si tu veux forcer une date limite commune (ex. 30 sept 2025),
        remplace la ligne :
           endDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() + days);
        par :
           endDate = new Date("2025-09-30T23:59:59");

     💡 Smartphones : compatible (prompt + bannières OK sur iOS/Android).
     ================================================================ ---->
<script>
(function(){
  // --------- PARAMÈTRES LIEN ---------
  function qs(name){ try{ return new URL(window.location.href).searchParams.get(name); }catch(_){ return null; } }
  var VUNLIM = qs("vunlim");
  var VDATE  = qs("vdate");
  var VDAYS  = qs("vdays");
  var SHOW   = qs("vlabel") !== "off";
  var SETADM = qs("setadmin")==="1";
  var CLRADM = qs("clearadmin")==="1";
  var VADMIN = qs("vadmin");

  // --------- MESSAGES (FR/EN/SV) ---------
  var M = {
    fr:{expired:"⚠️ Ce test n’est plus disponible (expiré).", warn:"⚠️ Attention : ce test sera désactivé demain.",
        welcome:"✅ Ce test est valable jusqu’au ", unlim:"✅ Ce test est valable sans limite.", admin:"🛠️ Mode édition activé (illimité)"},
    en:{expired:"⚠️ This test is no longer available (expired).", warn:"⚠️ Warning: this test will be disabled tomorrow.",
        welcome:"✅ This test is valid until ",     unlim:"✅ This test is valid with no expiry.", admin:"🛠️ Edit mode enabled (no expiry)"},
    sv:{expired:"⚠️ Detta test är inte längre tillgängligt (har gått ut).",
  warn:"⚠️ Varning: detta test kommer att inaktiveras imorgon.",
  welcome:"✅ Detta test är giltigt till ",
  unlim:"✅ Detta test är giltigt utan tidsbegränsning.",
  admin:"🛠️ Redigeringsläge aktiverat (obegränsat)"},

  };
  function fmt(d, lang){
    var locales = {fr:"fr-FR", en:"en-US", sv:"sv-SE"};
    return d.toLocaleDateString(locales[lang]||"fr-FR", {year:"numeric", month:"long", day:"numeric"});
  }
  function toDateYMD(s){
    if(!s) return null;
    var m;
    if((m=s.match(/^(\d{4})-(\d{2})-(\d{2})$/))) return new Date(+m[1], m[2]-1, +m[3]);
    if((m=s.match(/^(\d{2})-(\d{2})-(\d{4})$/))) return new Date(+m[3], m[2]-1, +m[1]);
    if((m=s.match(/^(\d{4})(\d{2})(\d{2})$/)))   return new Date(+m[1], m[2]-1, +m[3]);
    if((m=s.match(/^(\d{2})(\d{2})(\d{4})$/)))   return new Date(+m[3], m[2]-1, +m[1]);
    return null;
  }
  function startOfDay(d){ return new Date(d.getFullYear(), d.getMonth(), d.getDate()); }

  // --------- IDENTIFIANTS PAR NOM FICHIER ---------
  var FILE = (location.pathname.split("/").pop() || "").toLowerCase();
  var mDays = FILE.match(/_(\d+)\s*(?:days|d)\b/i);
  var requestedDaysFromFile = parseInt(mDays ? mDays[1] : "7", 10);
  if(!Number.isFinite(requestedDaysFromFile) || requestedDaysFromFile < 1) requestedDaysFromFile = 7;
  if(requestedDaysFromFile > 30) requestedDaysFromFile = 30;

  var mUid = FILE.match(/_uid-([a-z0-9_-]+)/i);
  var UID = (mUid ? mUid[1] : "anon");

  var mVer = FILE.match(/_v(\d+)/i);
  var VERSION = "v" + (mVer ? mVer[1] : "1");

  var FILE_BASE = (FILE.split("_")[0] || "dsm");

  // --------- ADMIN : CODE PAR PROMPT + PERSISTANCE LOCAL ---------
  var ADMIN_CODE = "swedsleep"; // 🔒 Ton code complet (modifiable ici)
  var ADMIN_KEY  = "validity_admin";
  var isLocal = (location.protocol === "file:") || (location.hostname === "localhost") || (location.hostname === "127.0.0.1");

  try{
    if (SETADM) localStorage.setItem(ADMIN_KEY, "1");
    if (CLRADM) localStorage.removeItem(ADMIN_KEY);
  }catch(_){}

  var ADMIN = false;
  try{ ADMIN = localStorage.getItem(ADMIN_KEY)==="1"; }catch(_){}

  if (isLocal) ADMIN = true;
  if (VADMIN && String(VADMIN).toLowerCase() === ADMIN_CODE.toLowerCase()) ADMIN = true;

  // Si pas encore admin → demander le code
  if (!ADMIN){
    var ans = prompt("Entrez le code admin (tapez les premières lettres, ex. 'psy...') :");

    // 💡 Version actuelle (souple) : il suffit que l'entrée COMMENCE par le code
    if (ans && ADMIN_CODE.toLowerCase().startsWith(String(ans).toLowerCase())) {
      ADMIN = true;
      try{ localStorage.setItem(ADMIN_KEY, "1"); }catch(_){}
      alert("Mode édition activé (illimité).");
    }

    // ⚠️ Pour passer en mode STRICT (exiger le code complet) :
    // Remplace la ligne ci-dessus par :
    //   if (ans && ADMIN_CODE.toLowerCase() === String(ans).toLowerCase()) {
    // → Dans ce cas, il faudra taper tout le code exactement (ex. "swedsleep")
  }

  if (ADMIN){
    if (SHOW){
      document.write(
        "<div style='text-align:center;color:#0a7b32;font-weight:bold;line-height:1.6;margin:8px 0'>"
        + M.fr.admin + "<br>" + M.en.admin + "<br>" + M.sv.admin + "</div>"
      );
    }
    return; // pas d'expiration en mode admin
  }

  // --------- CALCUL ÉCHÉANCE POUR UTILISATEUR ---------
  var unlimited = false, endDate = null;

  if (VUNLIM === "1") {
    unlimited = true;
  } else if (VDATE) {
    endDate = toDateYMD(VDATE);
    if(!endDate) unlimited = true;
  } else if (VDAYS) {
    var daysParam = parseInt(VDAYS, 10);
    if (Number.isFinite(daysParam) && daysParam > 0) {
      var KEY_P = FILE_BASE + "_firstOpen_param_" + (UID||"anon") + "_" + (VERSION||"v1") + "_" + daysParam;
      var startISO_P = null;
      try{ startISO_P = localStorage.getItem(KEY_P); }catch(_){}
      if (!startISO_P){
        startISO_P = new Date().toISOString().slice(0,10);
        try{ localStorage.setItem(KEY_P, startISO_P); }catch(_){}
      }
      var startDate = toDateYMD(startISO_P) || new Date();
      endDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() + daysParam);
    } else {
      unlimited = true;
    }
  } else {
    var KEY_F = FILE_BASE + "_firstOpen_" + (UID||"anon") + "_" + (VERSION||"v1") + "_" + requestedDaysFromFile;
    var st = null;
    try{ st = localStorage.getItem(KEY_F); }catch(_){}
    if (!st){
      var firstOpenISO = new Date().toISOString().slice(0,10);
      try{ localStorage.setItem(KEY_F, firstOpenISO); }catch(_){}
      st = firstOpenISO;
    }
    var startDateF = toDateYMD(st) || new Date();
    endDate = new Date(startDateF.getFullYear(), startDateF.getMonth(), startDateF.getDate() + requestedDaysFromFile);
  }

  if (!SHOW) return;

  // --------- AFFICHAGE / BLOCAGE ---------
  var now = startOfDay(new Date());
  if (unlimited){
    document.write(
      "<div style='text-align:center;color:#0a7b32;font-weight:bold;line-height:1.6;margin:8px 0'>"
      + M.fr.unlim + "<br>" + M.en.unlim + "<br>" + M.sv.unlim + "</div>"
    );
    return;
  }

  endDate = startOfDay(endDate);
  var oneDay = 24*60*60*1000;
  var diffDays = Math.ceil((endDate - now)/oneDay);

  if (now > endDate){
    document.write(
      "<h2 style='color:#d00000;text-align:center;line-height:1.6;margin:10px 0'>"
      + M.fr.expired + "<br>" + M.en.expired + "<br>" + M.sv.expired + "</h2>"
    );
    window.__FORM_EXPIRED__ = true;
  } else {
    document.write(
      "<div style='text-align:center;color:#b10000;font-weight:700;line-height:1.6;margin:8px 0'>"
      + M.fr.welcome + fmt(endDate,"fr") + "<br>"
      + M.en.welcome + fmt(endDate,"en") + "<br>"
      + M.sv.welcome + fmt(endDate,"sv") + "</div>"
    );
    if (diffDays === 1){
      document.write(
        "<div style='background:#d00000;color:white;text-align:center;padding:10px;font-weight:bold;line-height:1.6'>"
        + M.fr.warn + "<br>" + M.en.warn + "<br>" + M.sv.warn + "</div>"
      );
    }
  }

  document.addEventListener("DOMContentLoaded", function(){
    if (window.__FORM_EXPIRED__){
      ["menuScreen","introScreen","main","summary"].forEach(function(id){
        var el = document.getElementById(id);
        if (el){ el.style.pointerEvents="none"; el.style.opacity="0.5"; }
      });
    }
  });
})();
</script>
<!-- ================================================================
     FIN DU BLOC DE VALIDITÉ
     ================================================================ -->
<script>
// Conserver l’état TTS s’il est déjà défini
window.ttsEnabled = (typeof window.ttsEnabled === "boolean") ? window.ttsEnabled : false;

// Libellés d’échelles (sv)
window.SCALE_LABELS = (typeof window.SCALE_LABELS !== "undefined" ? window.SCALE_LABELS : ({
  sv: {
    numeric : ["aldrig","ibland","ofta","mycket ofta","alltid"],
    verbal1 : ["inte alls","kanske","lite","ganska mycket","mycket"],
    verbal2 : ["dålig","rättvis","bra","mycket bra","utmärkt"],
    helpPrefix: "Välj 1–5"
  }
}));

/*
   NOTE DE RECALAGE (dsm71) :
   - Ajout de Q4 => tous les numéros de questions suivants sont décalés de +1.
   - Conséquences mises à jour ci-dessous.

   Notables (indices 0-based marqués "scale"):
   Ancien dsm70:  [5..25, 29,31,32, 33,34,35, 37, 41,42,43, 47,48,49]
   Nouveau dsm71: [6..26, 30,32,33, 34,35,36, 38, 42,43,44, 48,49,50]

   Commentaire explicatif mis à jour :
   Q28 / Q47 = texte seul (exclus échelle) ; Q31 (30) et Q33 (32) = forcer VERBAL2.
*/

// Indices 0-based à échelle (notables) — (marquer indice= Q-1)
var notables = [];
window.NOTABLES_SET = new Set([]);// Shim TTS (sécurité)
window.ttsEnabled = (typeof window.ttsEnabled === "boolean") ? window.ttsEnabled : false;

// Questions MIXTES (texte → puis échelle 1–5) — RECALÉ (+1)
window.MIXED_QUESTIONS = new Set([28, 29, 35, 36, 37, 38, 39, 40]);

// Cartographie VERBAL2 — en entrée 1-based → conversion 0-based
// Ancien dsm70: "30,32" (→ 29,31). Nouveau dsm71: "31,33" (→ 30,32).
function __toZeroBasedSet(csv){
  return new Set(
    String(csv).split(/[,;\s]+/)
      .map(s => parseInt(s,10))
      .filter(n => Number.isInteger(n) && n >= 1)
      .map(n => n - 1)
  );
}

const VERBAL2_SET = __toZeroBasedSet("31,33");
// VERBAL1 — en entrée 1-based → converti en 0-based
const VERBAL1_SET = __toZeroBasedSet("25,26"); // Q25 & Q26

// Type d’échelle — priorité à Q31/Q33 → VERBAL2 (indices 0-based: 30, 32)
function getScaleTypeForQuestion(qIndex){
  // Priorité explicite aux VERBAL2 (Q31/Q33 → indices 30,32)
  if (qIndex === 30 || qIndex === 32) return "verbal2";
  if (VERBAL2_SET.has(qIndex))       return "verbal2";

  // Nouveau : VERBAL1 réels (Q25/Q26 → indices 24,25)
  if (typeof VERBAL1_SET !== "undefined" && VERBAL1_SET.has(qIndex)) return "verbal1";

  return "numeric";
}

// Appliquer les libellés au moment d’ouvrir l’échelle
window.applyScaleLabels = function(qIndex){
  try{
    var L = SCALE_LABELS.sv;
    var t = getScaleTypeForQuestion(qIndex);
    var labels = (t==="verbal2") ? L.verbal2 : (t==="verbal1") ? L.verbal1 : L.numeric;

    var labelEl = document.getElementById("scoreLabel");
    if (labelEl){
      labelEl.textContent = L.helpPrefix + ": " + labels.map((x,i)=>(i+1)+"="+x).join(", ");
    }
    var si = document.getElementById("scoreInput");
    if (si){ si.min="1"; si.max="5"; }
  }catch(_){}
};

// À l’initialisation UI : marquer les notables en type "scale" et surveiller l’ouverture du bloc score
document.addEventListener("DOMContentLoaded", function(){
  try{
    if (Array.isArray(window.questions)){
      notables.forEach(function(i){
        if (window.questions[i]) window.questions[i].type = "scale";
      });
    }
  }catch(_){}

  try{
    var sc = document.getElementById("scoreContainer");
    if (sc){
      var mo = new MutationObserver(function(){
        try{
          if (sc.style.display !== "none"){
            window.applyScaleLabels(window.currentQuestion);
          }
        }catch(_){}
      });
      mo.observe(sc, {attributes:true, attributeFilter:["style","class"]});
    }
  }catch(_){}
});
</script>
<!-- ===== /PRELUDE ===== -->
<script>
    /* Remplacez ces tableaux par vos questions réelles.
       Laissez les clés (DSM, SOMMEIL, NEUROLOGIE, PSYCHIATRIE, MEDEG) et les langues. */
    window.QUESTIONNAIRE_BANK = {
      DSM: {
        Français: [
          { section: 1, skipIfNon: true, text: "Avez-vous eu récemment des périodes de tristesse ? (Si non, passer à la section suivante)" },
          { id:"DSM_FR_Q1", type:"oui-non", texte:"Ces deux dernières semaines, vous êtes-vous senti(e) déprimé(e) ?" },
          { id:"DSM_FR_Q2", type:"texte",   texte:"Pouvez-vous préciser ?" }
        ],
        English: [
          { section: 1, skipIfNon: true, text: "Have you recently had periods of sadness? (If no, skip to next section)" },
          { id:"DSM_EN_Q1", type:"oui-non", texte:"In the last two weeks, have you felt depressed?" },
          { id:"DSM_EN_Q2", type:"texte",   texte:"Please specify." }
        ],
        Svenska: [
          { section: 1, skipIfNon: true, text: "Har du nyligen haft perioder av nedstämdhet? (Om nej, gå vidare)" },
          { id:"DSM_SV_Q1", type:"oui-non", texte:"Har du känt dig deprimerad de senaste två veckorna?" },
          { id:"DSM_SV_Q2", type:"texte",   texte:"Förklara gärna." }
        ]
      },
      SOMMEIL: {
        Français: [
          { section: 1, skipIfNon: true, text: "Avez-vous des difficultés d’endormissement ? (Si non, passer à la section suivante)" },
          { id:"SOM_FR_Q1", type:"oui-non", texte:"Avez-vous des difficultés à vous endormir ?" },
          { id:"SOM_FR_Q2", type:"texte",   texte:"À quelle fréquence ?" }
        ],
        English: [
          { section: 1, skipIfNon: true, text: "Do you have trouble falling asleep? (If no, skip to next section)" },
          { id:"SOM_EN_Q1", type:"oui-non", texte:"Do you have difficulty falling asleep?" },
          { id:"SOM_EN_Q2", type:"texte",   texte:"How often?" }
        ],
        Svenska: [
          { section: 1, skipIfNon: true, text: "Har du svårt att somna? (Om nej, gå vidare)" },
          { id:"SOM_SV_Q1", type:"oui-non", texte:"Har du svårt att somna?" },
          { id:"SOM_SV_Q2", type:"texte",   texte:"Hur ofta?" }
        ]
      },
      NEUROLOGIE: {
        Français: [
          { section: 1, skipIfNon: true, text: "Avez-vous eu des maux de tête récents ? (Si non, section suivante)" },
          { id:"NEURO_FR_Q1", type:"oui-non", texte:"Maux de tête fréquents ?" },
          { id:"NEURO_FR_Q2", type:"texte",   texte:"Précisez la fréquence." }
        ],
        English:  [
          { section: 1, skipIfNon: true, text: "Any recent headaches? (If no, next section)" },
          { id:"NEURO_EN_Q1", type:"oui-non", texte:"Frequent headaches?" },
          { id:"NEURO_EN_Q2", type:"texte",   texte:"How often?" }
        ],
        Svenska:  [
          { section: 1, skipIfNon: true, text: "Har du haft huvudvärk nyligen? (Om nej, nästa avsnitt)" },
          { id:"NEURO_SV_Q1", type:"oui-non", texte:"Ofta huvudvärk?" },
          { id:"NEURO_SV_Q2", type:"texte",   texte:"Hur ofta?" }
        ]
      },
      PSYCHIATRIE: {
        Français: [ { section:1, skipIfNon:true, text:"Section psychiatrie…" } ],
        English:  [ { section:1, skipIfNon:true, text:"Psychiatry section…" } ],
        Svenska:  [ { section:1, skipIfNon:true, text:"Psykiatri avsnitt…" } ]
      },
      MEDEG: {
        Français: [ { section:1, skipIfNon:true, text:"Médecine générale…" } ],
        English:  [ { section:1, skipIfNon:true, text:"General medicine…" } ],
        Svenska:  [ { section:1, skipIfNon:true, text:"Allmänmedicin…" } ]
      }
    };
  </script>
<!-- ========== /BANQUE DE QUESTIONS ========== -->
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title id="pageTitle">Questionnaire</title>
<style>
    body{
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      margin: 0;
      padding: 0;
      color: #333;
    }
    header, footer{
      background-color: #0056cc;
      color: #fff;
      padding: 1em;
      text-align: center;
    }
    section{
      background-color: #fff;
      margin: 1.5em auto;
      padding: 1.5em;
      border-radius: 8px;
      max-width: 900px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1, h2{
      color: #0056cc;
      margin-top: 0;
    }
    /* Barre de titre compacte */
    #titleBar{
      display:flex;
      gap:10px;
      justify-content:center;
      align-items:baseline;
      margin:0;
    }
    #versionNum{ font-weight:normal; opacity:.95; }
    /* Instructions */
    .instructions{
      background-color:#ffffcc;
      color:#000;
      font-size:1em;
      padding:10px;
      border-radius:5px;
      margin-bottom:10px;
    }
    .instructions span{ color:#c00; font-weight:bold; }
    #microStatus{ font-weight:bold; margin-left:10px; color:red; }
    .question-number{ font-weight:bold; margin-bottom:5px; }
    .section-number{ color:#0056cc; font-weight:bold; margin-bottom:10px; }
    textarea, input[type="text"], input[type="number"]{
      width:96%;
      font-size:1em;
      padding:8px;
      margin-top:5px;
      border:1px solid #ccc;
      border-radius:4px;
      min-height:40px;
    }
    button{
      background-color:#0056cc;
      color:#fff;
      border:none;
      padding:10px 18px;
      margin:8px 5px;
      border-radius:4px;
      cursor:pointer;
      font-size:1em;
    }
    button:hover{ background-color:#004bb5; }
    .error{ color:red; margin-top:8px; min-height:20px; font-weight:bold; }
    #progressContainer{ background:#ddd; width:100%; height:8px; margin-top:15px; border-radius:5px; }
    #progressBar{ background:#0056cc; height:8px; width:0%; border-radius:5px; }
    #scoreContainer{ display:none; margin-top:10px; }
    #scoreContainer label{ color:red; font-weight:bold; }
    ul{ list-style:none; padding:0; }
    textarea.editable{ width:95%; min-height:50px; margin-top:5px; margin-bottom:15px; border:1px solid #ccc; border-radius:5px; }
    /* Accueil : selects plus petits et lisibles */
    #menuScreen select{
      width:50%;
      max-width:360px;
      font-size:14px;
      padding:4px 8px;
      height:32px;
      background:#fff;
      color:#000;
      border:1px solid #888;
      box-shadow:none;
      appearance:auto;
    }
    #menuScreen label{
      display:inline-block;
      min-width:140px;
      margin-bottom:4px;
    }
    /* >>> AJOUT : rendre le texte du header lisible (blanc sur bandeau bleu) <<< */
    header h1, header #titleBar, header #titleBar span {
      color: #fff !important;
    }
    /* >>> AJOUT : rendre le texte du header lisible (blanc sur bandeau bleu) <<< */
    header h1, header #titleBar, header #titleBar span { color: #fff !important; }
    /* Intro d'accueil (bandeau bleu) */
    .header-intro{
      margin:.25em auto 0;
      max-width:900px;
      font-size:.95em;
      line-height:1.35;
      opacity:.95;
    }
    header .header-intro{ color:#fff; }
    /* Intro un peu plus grande dans la banderole */
    header .header-intro{
      font-size: 1.15em;
      line-height: 1.45;
      font-weight: 500;
      opacity: 1;
    }

</style>
<script>
// === BOOT LANG PAR DÉFAUT → SVENSKA (DSM) ===
(function(){
  window.currentForm = "NEUROLOGIE";
  window.currentLang = "Svenska";

  // Disponibilités côté menu (forcer DSM→Svenska)
  window.AVAILABLE_LANGS_BY_FORM = { DSM:[], Sommeil:[], Psych:[], Neurology:[], MedGle:[], NEUROLOGIE:["Svenska"] };
  window.availableLangsByForm = window.AVAILABLE_LANGS_BY_FORM;

  // Purge d’anciens choix mémorisés qui repassent en FR
  try {
    localStorage.removeItem("ui_lang");
    localStorage.removeItem("lastLang");
    localStorage.removeItem("menu_lang");
  } catch(_) {}

  document.addEventListener("DOMContentLoaded", function(){
    try{
      var fSel = document.getElementById("questionnaireSelect");
      var lSel = document.getElementById("langSelect");
      if (fSel) fSel.value = "NEUROLOGIE";
      if (lSel){
        var hasSv = Array.from(lSel.options||[]).some(function(o){return o && o.value==="Svenska";});
        if (!hasSv) lSel.add(new Option("Svenska","Svenska"));
        lSel.value = "Svenska";
      }
      var err = document.getElementById("menuError");
      if (err) err.textContent = "";
      if (typeof window.applyHomeUI === "function") {
        window.applyHomeUI("Svenska");
      } else {
        var h2 = document.querySelector("#menuScreen h2");
        if (h2 && window.UI_STRINGS && window.UI_STRINGS["Svenska"]) {
          h2.textContent = window.UI_STRINGS["Svenska"].homeTitle;
        }
      }
    }catch(_){}
  });
})();

</script>

<body>
<header>
<h1 id="titleBar">
<span id="mainTitle">Frågeformulär Neurologi</span>
      —
      <span id="versionNum">Version 70-1</span>
</h1>
<div aria-live="polite" class="header-intro" id="headerIntro" style="display:none"></div>
</header>
<!-- ======================================================
       ACCUEIL / INTRO / QUESTIONNAIRE / RÉSUMÉ
       ====================================================== -->
<section id="menuScreen">
<h2>Sélectionner Questionnaire et Langue</h2>
<label for="questionnaireSelect">Questionnaire :</label>
<select id="questionnaireSelect"></select>
<br/><br/>
<!-- ▼▼ TTS: sélecteur de voix par langue ▼▼ -->
<div id="voiceRow" style="margin-top:10px;">
<label for="voiceSelect">Voix (selon l’appareil) :</label>
<select id="voiceSelect" style="width:50%;max-width:360px;height:32px;"></select>
<button id="testVoiceBtn" style="margin-left:6px;" type="button">Test voix</button>
<div id="voiceHint" style="font-size:.9em;opacity:.8;margin-top:4px;"></div>
</div>
<!-- ▲▲ TTS: sélecteur de voix par langue ▲▲ -->
<label for="langSelect">Langue :</label>
<select id="langSelect"></select>
<br/><br/>
<div class="error" id="menuError"></div>
<button id="nextLangBtn">Continuer</button>
</section>
<section id="introScreen" style="display:none;">
<h2>Introduction</h2>
<p id="introText">Detta frågeformulär är anonymt.
Jag kommer att ställa frågor som rör de senaste 2 månaderna.
Dessa frågor är grupperade i avsnitt.
Det tar cirka 15 minuter. Du kan ta en paus.
Om du gör ett misstag kan du korrigera det.
Svara HELST på tangentbordet men du kan också använda mikrofonen.
Tala sedan långsamt och tydligt, avsluta dina svar genom att säga SLUT.
I slutet kan du korrigera dina svar, lägga till en kommentar, kopiera dina svar, spara dem som en PDF och skicka dem för analys med hjälp av de knappar som finns.
Om du inte vill höra frågorna, tryck på RÖST-knappen.</p>
<label id="labelCode"></label><br/>
<input id="codeInput" inputmode="numeric" maxlength="4" pattern="[0-9]*" type="text"/>
<div class="error" id="introErrorMsg"></div>
<br/>
<button id="startBtn">Commencer</button>
</section>
<section id="main" style="display:none;">
<div class="instructions" id="instructionBox">
      Au clavier <span>RETOUR</span>, en vocal dire <span>STOP</span>
<span id="microStatus">🎤 Micro fermé</span>
</div>
<div class="section-number" id="sectionNum"></div>
<div class="question-number" id="questionNum"></div>
<div id="questionText"></div>
<textarea id="answerInput"></textarea>
<div class="error" id="mainErrorMsg"></div>
<div id="scoreContainer">
<label id="scoreLabel"></label>
<br/>
<input id="scoreInput" max="5" min="1" type="number"/>
<button id="validateScoreBtn">OK</button>
</div>
<div id="progressContainer"><div id="progressBar"></div></div>
<button id="validerBtn">Valider</button>
<button id="corrigerBtn" type="button">KORRIGERA</button>
<button id="pauseBtn">Pause</button>
<button id="voiceBtn" onclick="(function(){var SR=window.SpeechRecognition||window.webkitSpeechRecognition;if(!SR){alert('Taligenkänning stöds inte i denna webbläsare.');return;}if(!(window.isSecureContext||location.protocol==='https:'||location.hostname==='localhost')){alert('Mikrofon kräver HTTPS (eller localhost) på Android.');return;}if(!window.__rec){window.__rec=new SR();var lang=(window.currentLang==='Français'?'fr-FR':(window.currentLang==='English'?'en-US':'sv-SE'));window.__rec.lang=lang;window.__rec.interimResults=true;window.__rec.continuous=false;window.__rec.maxAlternatives=1;window.__rec.onstart=function(){var b=document.getElementById('voiceBtn');if(b){var on=(window.messagesInterface&amp;&amp;window.currentLang&amp;&amp;window.messagesInterface[window.currentLang]?window.messagesInterface[window.currentLang].microOn:'🎤 Mikrofon på');b.textContent=on;b.classList.add('active');}};window.__rec.onend=function(){var b=document.getElementById('voiceBtn');if(b){var off=(window.messagesInterface&amp;&amp;window.currentLang&amp;&amp;window.messagesInterface[window.currentLang]?window.messagesInterface[window.currentLang].microOff:'🎤 Mikrofon av');b.textContent=off;b.classList.remove('active');}};window.__rec.onerror=function(e){console.warn('Reco error',e);var b=document.getElementById('voiceBtn');if(b){var off=(window.messagesInterface&amp;&amp;window.currentLang&amp;&amp;window.messagesInterface[window.currentLang]?window.messagesInterface[window.currentLang].microOff:'🎤 Mikrofon av');b.textContent=off;b.classList.remove('active');}};}var ok=true; try{window.__rec.start();}catch(e){ok=false;}if(!ok &amp;&amp; navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getUserMedia){navigator.mediaDevices.getUserMedia({audio:true}).then(function(s){try{s.getTracks().forEach(function(t){t.stop();});}catch(_){}}).then(function(){setTimeout(function(){try{window.__rec.start();}catch(_){}} , 0);});}})()" type="button">🎙️ Mikrofon</button>
<button id="ttsToggleBtn" onclick="(function(){var cur=(typeof window.ttsEnabled==='undefined'?true:!!window.ttsEnabled);window.ttsEnabled=!cur;try{window.ttsEnabled=window.ttsEnabled;}catch(_){ }if(!window.ttsEnabled &amp;&amp; window.speechSynthesis &amp;&amp; speechSynthesis.cancel){try{speechSynthesis.cancel();}catch(_){}}try{if(typeof updateTTSBtn==='function')updateTTSBtn();}catch(_){ }})()">Röst</button>
</section>
<section id="summary" style="display:none;">
<h2 id="summaryTitle">Sammanfattning och korrigering</h2>
<p><strong id="summaryCodeLabel">Formulärkod :</strong> <span id="resumeCode"></span></p>
<ul id="answersList"></ul>
<label for="globalComment" id="globalCommentLabel">Kommentarer</label>
<textarea id="globalComment" placeholder="Votre commentaire global…"></textarea>
<br/>
<button id="pdfBtn">Exportera PDF</button>
<button id="copyBtn">Kopiera</button>
<button id="closeBtn">Slutför</button>
<!-- CODICENT: send button + status (ensured) -->
<button id="sendToCodicentBtn">Skicka för analys</button>
<div id="codicentStatus" style="display:none; margin-top:8px; font-weight:600;"></div>
</section>
<footer style="text-align:center;font-size:.85em;color:#ddd;margin-top:2em;">
<p>© 2025 SwedSleep - vers Q70-1</p>
</footer>
<!-- ======================================================
       SCRIPT – CONFIG, DONNÉES, FONCTIONS
       ====================================================== -->
<script>
  // ─────────────────────────────────────────────────────────

// CONFIG : titre dynamique (nom + version)
// ─────────────────────────────────────────────────────────
const APP = {
  nom: "Questionnaire NEURO",
  version: "Version Q70 -1"
};

// Mapping des titres selon la langue (fallback = APP.nom)
const HEADER_TITLES = {
  "Français": "Questionnaire Neurologie",
  "English":  "Questionnaire Neurology",
  "Svenska":  "Frågeformulär Neurologi"
};

// Récupère le libellé localisé sans modifier APP.nom
function getHeaderTitle(){
  const lang = (window.currentLang || "Français");
  return HEADER_TITLES[lang] || APP.nom;
}

function majTitrePage(nom = "", version = ""){
  // Si pas de nom/version passés → utiliser la version localisée + APP.version
  const title   = nom && nom.trim() ? nom : getHeaderTitle();
  const ver     = version && version.trim() ? version : APP.version;
  try{
    document.getElementById('pageTitle').textContent = ver ? (title + " - " + ver) : title;
  }catch(_){}
}

function updateHeaderBar(){
  try{
    document.getElementById("mainTitle").textContent  = getHeaderTitle();
    document.getElementById("versionNum").textContent = APP.version;
  }catch(_){}
  majTitrePage(); // met aussi à jour le <title> de l’onglet
}
  // ─────────────────────────────────────────────────────────
  // DONNÉES : formulaires, intros, messages, questions
  // ─────────────────────────────────────────────────────────
  const disabledForms = ["DSM", "MedGle", "Psych", "Sommeil"];
  const introByForm = {
    "Français": {
      unavailable: "indisponible",
      DSM: "Ce questionnaire est anonyme.\nJe vais vous poser des questions se rapportant aux 2 derniers mois.\nCes questions sont regroupées en sections.\nComptez environ 15 min. Vous pouvez faire une pause.\nEn cas d’erreur, vous pouvez corriger.\nRépondez DE PREFERENCE sur le clavier mais vous pouvez aussi utiliser le micro.\nParlez alors lentement et distinctement, terminez vos réponses en disant STOP ou VALIDER.\nÀ la fin, vous pourrez corriger vos réponses, ajouter un commentaire, copier vos réponses, les enregistrer en PDF et les envoyer pour analyse grâce aux boutons prévus à cet effet.\nSi vous ne voulez pas entendre les questions pressez la touche VOCAL",
      Sommeil: "Questionnaire Sommeil (FR)…",
      Psych: "Questionnaire Psych (FR)…",
      Neurology: "Questionnaire Neurologie (FR)…",
      MedGle: "Questionnaire Médecine Générale (FR)…",
      comments: "Kommentarer"},
    "English": {
      unavailable: "unavailable",
      DSM: "This form screens DSM-5 related symptoms. Answer freely. You can pause anytime.",
      Sommeil: "Sleep questionnaire (EN)…",
      Psych: "Psych questionnaire (EN)…",
      Neurology: "Neurology questionnaire (EN)…",
      MedGle: "General Practice questionnaire (EN)…",
      comments: "Comments"},
    "Svenska": {
      unavailable: "otillgänglig",
      DSM:"Detta frågeformulär är anonymt.\nJag kommer att ställa frågor som rör de senaste 2 månaderna.\nDessa frågor är grupperade i avsnitt.\nDet tar cirka 15 minuter. Du kan ta en paus.\nOm du gör ett misstag kan du korrigera det.\nSvara HELST på tangentbordet men du kan också använda mikrofonen.\nTala sedan långsamt och tydligt, avsluta dina svar genom att säga SLUT.\nI slutet kan du korrigera dina svar, lägga till en kommentar, kopiera dina svar,spara dem som en PDF och skicka dem för analys med hjälp av de knappar som finns\nOm du inte vill höra frågorna, tryck på RÖST-knappen",
      Sommeil: "Sömnformulär (SV)…",
      Psych: "Psykologiformulär (SV)…",
      Neurology: "Neurologiformulär (SV)…",
      MedGle: "Allmänmedicin formulär (SV)…",
      comments: "Kommentarer"},
      sendForAnalysis: "Skicka för analys",
      codicentSuccessPrefix: "Envoyé à Codicent ! ID : ",
      codicentErrorPrefix: "Erreur d’envoi à Codicent : ",
      noTokenMsg: "Aucun jeton ?token=… trouvé dans l’URL.",
      sendForAnalysis: "Skicka för analys"
      };
  let config = {
    nomQuestionnaire: "Frågeformulär Neurologi",
    version: "v Q70-1",
    couleursBande: "#ffffcc",
    langues: ["Français","English","Svenska"],
 // Temps de reponse avant de passer a la prochaine question - "minDelayDefault" doit etre plus petit que que "tempsMaxReponse")
    tempsBaseReponse: 1200,// delai de base avant de passer à la question suivante, ici defaut 1200 =1,2 sec
    tempsParCaractere: 50,//delai supplemntaire par caractère saisi dans la réponse (50 ms/caractere)
    tempsMaxReponse: 4000, // plafond maximum (ici 4000= 4 sec)
// <<< nouveaux planchers >>>
  minDelayDefault: 1200, // 1.2 s
  minDelayNo:      1000, // 1.0 s pour "non/no/nej"
  minDelaySkip:    1500  // 1.5 s si saut de section
  };
  // QUESTIONS – liste complète (sections 1 → 23)
  let questions = [
{ section: 1, text: "Hur gammal är du ?" },
{ text: "Är du en man, en kvinna eller annat ?" },
{ text: "Vad år ditt yrke eller dina dagliga aktiviteter:" },
{ text: "Vilka mediciner tar du dagligen (inklusive naturmedel och kosttillskott):" },
{ text: "Vilka sjukdomar har du haft de senaste 10 år ?" },
{ text: "Har du några allergier ?" },
{ section: 2, text: "Vad är det främsta skälet till att du söker neurologisk vård?" },
{ text: "När började dina symtom?" },
{ text: "Hur utvecklades de (plötsligt eller gradvis)?" },
{ text: "Har symtomen blivit bättre, sämre eller oförändrade över tid?" },
{ text: "Är besvären konstant närvarande eller kommer de i episoder?" },
{ section: 3, text: "Förekommer huvudvärk eller ansiktssmärta?" },
{ text: "Var sitter smärtan, hur känns den (molande, huggande, tryckande)?" },
{ text: "Hur ofta och hur länge varar den?" },
{ text: "Vad utlöser eller lindrar smärtan?" },
{ section: 4, text: "Har du upplevt eller upplever du svaghet i armar, ben eller ansikte?" },
{ text: "Har du problem med finmotorik eller gångsvårigheter?" },
{ text: "Upplever du skakningar, stelhet eller ofrivilliga rörelser?" },
{ text: "Har du muskelkramper, stelhet eller ofrivilliga muskelryckningar?" },
{ text: "Har du märkt muskelförtvining eller minskad muskelmassa?" },
{ section: 5, text: "Har du upplevt/upplever du domningar, stickningar eller känselbortfall?" },
{ text: "Var på kroppen uppstår detta?" },
{ section: 6, text: "Upplever du yrsel, ostadighet eller falltendens?" },
{ text: "Har du problem med koordination (t.ex. knäppa knappar, skriva, hålla i bestick)?" },
{ section: 7, text: "Har du haft synförändringar (dubbelseende, synbortfall, suddig syn)?" },
{ text: "Har du haft problem med hörsel eller öronsus (tinnitus)?" },
{ text: "Har du ljuskänslighet eller ljudkänslighet?" },
{ section: 8, text: "Har du haft svårt att tala, uttala ord eller hitta rätt ord?" },
{ text: "Har andra upplevt att ditt tal blivit otydligt?" },
{ section: 9, text: "Har du märkt förändringar i lukt- eller smaksinne?" },
{ section: 10, text: "Har du svårigheter med minne eller koncentration?" },
{ text: "Har du svårt att planera, organisera eller följa instruktioner?" },
{ section: 11, text: "Har du upplevt svimning, medvetslöshet, kramper eller oförklarliga episoder av frånvaro? i så fall förklara" },
{ text: "Har andra observerat konstiga rörelser eller beteendeförändringar under episoder?" },
{ section: 12, text: "Har du haft eller har du svårt att tömma blåsan, trängningar, svårigheter att kissa eller täta urinträngningar? i så all förklara" },
{ text: "Har du haft problem med avföring (förstoppning eller inkontinens)?" },
{ text: "Har du upplevt blodtrycksfall, hjärtklappning eller stark svettning utan orsak?" },
{ section: 13, text: "Sover du gott om nätterna?" },
{ text: "Snarkar du, har du sömnapné eller andningsuppehåll under sömn?" },
{ text: "Har du drabbats av plötslig muskelsvaghet (kataplexi) eller ofrivilligt insomnande?" },
{ text: "Har du livliga drömmar, mardrömmar eller rörelser under sömnen?" },
{ section: 14, text: "Har du haft skallskador eller hjärnskakning?" },
{ text: "Tidigare stroke eller TIA?" },
{ text: "Har du haft infektioner i nervsystemet (t.ex. hjärnhinneinflammation, borrelia)?" },
{ text: "Finns neurologiska sjukdomar i familjen (t.ex. epilepsi, MS, Parkinson, demens)?" },
{ section: 15, text: "Upplever du mycket stress i vardagen?" },
{ text: "Har du haft ångest, depression eller annan psykiatrisk diagnos?" },
{ text: "Har symtomen påverkat ditt humör eller din personlighet?" },
{ text: "Hur mycket alkohol dricker du ?" },
{ text: "Röker du eller använder andra nikotinprodukter – snus ? I så fall hur mycket" },
{ text: "Vilket fysiskt aktivitet/träning gör du ?  Hur ofta ?" },
{ section: 16, text: "Har du diabetes, sköldkörtelsjukdom eller annan hormonell sjukdom?" },
{ text: "Har du förändrat vikt (upp eller ner) utan tydlig orsak?" },
{ section: 17, text: "Har symtomen uppkommit i samband med att du började med en ny medicin?" },
{ section: 18, text: "Finns det något särskilt du oroar dig för?" },
{ text: "Vad hoppas du få hjälp med i konsultationen?" }
]
// expose questions globally
window.questions = questions;
window.totalQuestions = questions.length;
;
// Appliquer les flags skip à la 1ʳᵉ question des sections 5, 7, 22 (utilise window.SECTIONS_SKIP)
if (typeof preparerQuestions === "function") {
  if (!Array.isArray(window.SECTIONS_SKIP)) window.SECTIONS_SKIP = [5, 7, 11, 22];
  preparerQuestions(questions, window.SECTIONS_SKIP);
}

  // Indices de questions à échelle (1–5) : marquage "scale"
  // ─────────────────────────────────────────────────────────
// Questions en MODE MIXTE (texte → puis score 1–5)
// Référence 0-based (N° question = index+1).
// Exemple: Q28=27, Q29=28, Q33=32, Q34=33, Q35=34, Q36=35, Q38=37

// (Note) Texte d’abord (ENTER/STOP/SLUT) → ouverture automatique de l’échelle 1–5.
// === MULTI-ÉCHELLES + LANG + MIXTE (JS-ONLY, collé dans ce <script>) ===
// 0) Langue active (suit currentLang si updateInterfaceLang l'actualise)
window.SCALE_LANG = window.SCALE_LANG || "sv";
// 1) Tables 1-based (comme notables)
     // ex: "30, 33"
   // Q25 (index 24) en Text2
// 2) MIXTE (texte → score) en 0-based (garde si tu l'utilises déjà)

// Alias (si le code utilise le nom sans window.)

// 3) Conversion 1-based → 0-based
// 4) Libellés par langue (5 éléments = scores 1→5)

// ─────────────────────────────────────────────
// Étiquettes d’échelle par langue
// ─────────────────────────────────────────────

// ─────────────────────────────────────────────
// Questions notables (indices 0-based)
// ─────────────────────────────────────────────
// Q27 (26) retirée → texte seul
// Q30 (29) ajoutée → échelle VERBAL2
// Q32 (31) reste → échelle VERBAL2
// Q46 (45) retirée → texte seul
var notables = [];
window.NOTABLES_SET = new Set([]);// Marquage des questions "scale"
notables.forEach(i => { if (questions[i]) questions[i].type = "scale"; });

// Accès rapide

// Tables verbales 1-based → sets 0-based
     // adapte si besoin
  // ✅ Q30/Q32 verbale2

// Suivre la langue active via updateInterfaceLang si présent
(function(){
  try{
    function __mapLang(x){ x=(x||"").toLowerCase(); if(x.includes("sv"))return"sv"; if(x.includes("fr"))return"fr"; if(x.includes("en"))return"en"; return"en"; }
    const __old = window.updateInterfaceLang;
    window.updateInterfaceLang = function(){
      try{ if (typeof __old==="function") __old(); }catch(_){}
      try{
        window.SCALE_LANG = __mapLang(window.currentLang||"sv");
        const sc = document.getElementById("scoreContainer");
        if (sc && sc.style.display!=="none"){ window.applyScaleLabels(window.currentQuestion); }
      }catch(_){}
    };
  }catch(_){}
})();
// ─────────────────────────────────────────────────────────
// ─── MODIF (GPT): Questions à ÉCHELLE VERBALE (affichage) ───
// Indique ici les indices 0-based des questions qui doivent afficher
// les libellés verbaux suédois pour l'échelle 1–5, au lieu du texte
// standard (aldrig/sällan/ibland/ofta/mycket ofta).
// Ex.: Q25=24, Q26=25, Q30=29, Q32=31
// ➜ Pour ajouter d'autres questions plus tard, ajoute simplement leur index :
const VERBAL_SCALE_QUESTIONS = new Set([24,25,30,32,37]);

// Apply Swedish labels to 1–5 controls for current question
function __applySwedishLabelsForCurrent(){
  try{
    var q = window.currentQuestion;
    if (typeof q !== "number") return;
    var isText2 = (q===30||q===32);
    var labels = isText2 ? ["dålig","rättvis","bra","mycket bra","utmärkt"]
                         : ["inte alls","kanske","lite","ganska mycket","mycket"];
    // Buttons
    var btns = document.querySelectorAll(".score-btn, .score-option, .btn-score, .scale-btn, [data-score], [data-value]");
    for (var i=0;i<btns.length;i++){
      var b=btns[i];
      var val = b.getAttribute("data-value") || b.getAttribute("data-score") || b.value || (b.textContent||"").trim();
      var n = parseInt(val,10);
      if (n>=1 && n<=5){
        b.textContent = n + " \u2013 " + labels[n-1];
        try{ b.setAttribute("title", labels[n-1]); }catch(_){}
      }
    }
    // Radios + labels
    var radios = document.querySelectorAll("input[type='radio'][value]");
    for (var j=0;j<radios.length;j++){
      var r = radios[j];
      var n2 = parseInt(r.value,10);
      if (n2>=1 && n2<=5){
        var lab = null;
        if (r.id) lab = document.querySelector("label[for='"+r.id.replace(/([:\\.\\[\\]\\(\\)])/g,"\\\\$1")+"']");
        if (!lab){
          var next = r.nextElementSibling;
          if (next && next.tagName && next.tagName.toLowerCase()==="label") lab = next;
        }
        if (lab){
          lab.textContent = n2 + " \u2013 " + labels[n2-1];
        }
      }
    }
  }catch(_){}
}

// ─────────────────────────────────────────────────────────
// Sections à skip (si la 1re Q répond "non" etc.)
  window.SECTIONS_SKIP = [5, 7, 11, 22];
  // ─────────────────────────────────────────────────────────
  // MESSAGES UI (FR/EN/SV)
  // ─────────────────────────────────────────────────────────
  let messagesInterface = {
    "Français": {
      btnPDF:"Exportera PDF", btnCopy:"Kopiera", btnClose:"Slutför",
      menuTitle:"Sélectionner Questionnaire et Langue",
      labelQuestionnaire:"Questionnaire :",
      labelLangue:"Langue :",
      continuer:"Continuer",
      intro:"Ce questionnaire est anonyme et vous aide à évaluer votre bien-être mental.",
      codeLabel:"Entrez maintenant un code de votre choix à 4 chiffres en le tapant sur le clavier",
      start:"Commencer",
      pause:"Pause", reprendre:"Reprendre",
      microOff:"🎤 Micro fermé", microOn:"🎤 Micro actif",
      summaryTitle:"Sammanfattning och korrigering", codeLabelSummary:"Formulärkod :",
      errorCode:"Veuillez entrer un code à 4 chiffres valide.",
      errorScale:"Entrez un chiffre de 1 à 5 : 1=jamais, 2=rarement, 3=parfois, 4=souvent, 5=très souvent",
      ttsOn:"Vocal", ttsOff:"Silence",
      btnPDF:"Exportera PDF", btnCopy:"Kopiera", btnClose:"Slutför",
      promptFilename:"Entrez un nom de fichier (.txt)",
      defaultFilename:"Réponses_Questionnaire_",
      valider:"Valider", corriger:"Corriger",
      alertOption:"Option non installée, reprenez la 1ère option",
      alertSaved:"Vos réponses ont été enregistrées.",
      sectionLabel: "Section",
     questionLabel: "Question",
     introTitle: "Introduction",
      programme:"Programme",
      language:"Langue",
      globalCommentPlacehoder: "votre commentaire global",
      alertRewrite:"Réécrivez votre réponse"},
    "English": {
      btnPDF:"Export PDF", btnCopy:"Copy", btnClose:"Finish",
      menuTitle:"Select Questionnaire and Language",
      labelQuestionnaire:"Questionnaire:", labelLangue:"Language:",
      continuer:"Continue", intro:"This questionnaire is anonymous.",
      codeLabel:"Enter your 4-digit code:", start:"Start",
      pause:"Pause", reprendre:"Resume",
      microOff:"🎤 Micro off", microOn:"🎤 Micro on",
      summaryTitle:"Summary and correction", codeLabelSummary:"Questionnaire code:",
      errorCode:"Please enter a valid 5-digit code.",
      errorScale:"After your answer, enter a number 1–5:1=never, 2=rarely, 3=sometimes, 4=often, 5=very often",
      ttsOn:"Voice", ttsOff:"Silence",
      btnPDF:"Export PDF", btnCopy:"Copy", btnClose:"Finish",
      promptFilename:"Enter a filename (.txt)",
      defaultFilename:"Questionnaire_Answers_",
      valider:"Validate", corriger:"Correct",
      alertOption:"Option not installed, please select the first option.",
      alertSaved:"Your responses have been saved.",
      sectionLabel: "Section",
      questionLabel: "Question",
      introTitle: "Introduction",
      programme:"Program",
      language:"Language",
      globalCommentPlaceholder: "Your overall comment…",
      alertRewrite:"Rewrite your answer"},
    "Svenska": {
      btnPDF:"Exportera PDF", btnCopy:"Kopiera", btnClose:"Avsluta",
      menuTitle:"Välj formulär och språk",
      labelQuestionnaire:"Formulär:", labelLangue:"Språk:",
      continuer:"Fortsätt", intro:"Detta formulär är anonymt.",
      codeLabel:"Ange en fyrsiffriga kod:", start:"Starta",
      pause:"Paus", reprendre:"Återuppta",
      microOff:"🎤 Mikrofon av", microOn:"🎤 Mikrofon på",
      summaryTitle:"Sammanfattning och korrigering", codeLabelSummary:"Formulärkod:",
      errorCode:"Ange en giltig femsiffrig kod.",
      errorScale:"Ange en siffra: 1=aldrig, 2=sällan, 3=ibland, 4=ofta, 5=mycket ofta",
      ttsOn:"Röst", ttsOff:"Tyst",
      btnPDF:"Exportera PDF", btnCopy:"Kopiera", btnClose:"Avsluta",
      promptFilename:"Ange ett filnamn (.txt)",
      defaultFilename:"Formulär_Svar_",
      valider:"Bekräfta", corriger:"Korrigera",
      alertOption:"Alternativet är inte installerat, välj det första alternativet.",
      alertSaved:"Dina svar har sparats." ,
      sectionLabel: "Sektion",
      questionLabel: "Fråga",
      introTitle: "Introduktion",
      programme:"Program",
      language:"Språk",
      globalCommentPlaceholder: "Din allmänna kommentar…",
      alertRewrite:"Skriv om ditt svar"}
};  // <= fin de messagesInterface
 window.messagesInterface = messagesInterface; // ← on l’attache à window
// Texte d'instructions par langue (bandeau jaune)
window.instructionTextByLang = {
  'Français': 'Au clavier <span>RETOUR</span>, en vocal dire <span>STOP</span>',
  'English' : 'On keyboard press <span>ENTER</span>, by voice say <span>STOP</span>',
  'Svenska' : 'På tangentbordet tryck <span>RETUR</span>, med röst säg <span>SLUT</span>'
};
function refreshInstructionBanner(){
  const ib = document.getElementById('instructionBox');
  if (!ib) return;
  const m = (window.messagesInterface && window.messagesInterface[currentLang]) || window.messagesInterface['Français'];
  const instr = (window.instructionTextByLang && window.instructionTextByLang[currentLang]) || window.instructionTextByLang['Français'];
  const microText = (typeof listening !== 'undefined' && listening) ? m.microOn : m.microOff;
  ib.innerHTML = instr + ' <span id="microStatus">' + microText + '</span>';
}
  // ─────────────────────────────────────────────────────────
  // ÉTAT GLOBAL
  // ─────────────────────────────────────────────────────────
  let userCode = "", currentQuestion = 0;
  let answers = [];
  let paused = false, recognition = null, listening = false;
  let isValidating = false;
  if (typeof window.ttsEnabled === "undefined") window.ttsEnabled = true;
  let currentLang = "Svenska";
  let justCorrected = false;
  const isMobile = /Android|iPhone|iPad|iPod|SamsungBrowser/i.test(navigator.userAgent);
  const mapChiffres = { "un":"1","une":"1","deux":"2","trois":"3","quatre":"4","one":"1","two":"2","three":"3","four":"4","ett":"1","två":"2","tva":"2","tre":"3","fyra":"4" };
  // ─────────────────────────────────────────────────────────
  // PRÉPARATION DES SECTIONS / SKIP
  // ─────────────────────────────────────────────────────────
  function preparerQuestions(arr, sectionsSkip){
    let courant = null;
    arr.forEach((q, idx) => {
      if (typeof q.section !== "undefined") courant = q.section;
      else if (courant !== null)          q.section = courant;
      else                                q.section = 0;
      if (sectionsSkip.includes(q.section)){
        if (idx === 0 || arr[idx-1].section !== q.section) q.skipIfNon = true;
      }
    });
  }

  // ─────────────────────────────────────────────────────────
  // OUTILS UI
  function showNoSpeech(){
    const txt = (messagesInterface && messagesInterface[currentLang] && messagesInterface[currentLang].noSpeech) || "🎤 Pas de voix détectée";
    const ms  = document.getElementById("microStatus");
    if (ms){ ms.textContent = txt; ms.style.color = "orange"; }
    const err = document.getElementById("mainErrorMsg") || document.getElementById("menuError");
    if (err) err.textContent = txt;
  }
  // ─────────────────────────────────────────────────────────
  function jouerBipErreur(){
    try{
      const c=new (window.AudioContext||window.webkitAudioContext)();
      const o=c.createOscillator(); const g=c.createGain();
      o.type="sine"; o.frequency.value=440; g.gain.value=.1;
      o.connect(g); g.connect(c.destination);
      o.start(); o.stop(c.currentTime+.25);
    }catch(_){}
  }
  function updateProgress(){
    document.getElementById("progressBar").style.width = ((currentQuestion/questions.length)*100)+"%";
  }
  function updateTTSBtn(){
  var b = document.getElementById('ttsToggleBtn');
  if(!b) return;
  var enabled = (typeof window.ttsEnabled === 'boolean') ? window.ttsEnabled : false;
  try{
    b.textContent = enabled ? messagesInterface[currentLang].ttsOn : messagesInterface[currentLang].ttsOff;
    b.setAttribute('aria-pressed', enabled ? 'true' : 'false');
  }catch(_){
    try{ b.textContent = enabled ? 'Voice' : 'Silence'; }catch(__){}
  }
}

  function updateQuestionnaireLabels(){
    try{
      const sel=document.getElementById('questionnaireSelect'); if(!sel) return;
      const map = {
        'Français': { DSM:'DSM-5', Sommeil:'Sommeil', Psych:'Psych', Neurology:'Neurologie', MedGle:'Med Gle' },
        'English' : { DSM:'DSM-5', Sommeil:'Sleep',   Psych:'Psych', Neurology:'Neurology', MedGle:'GP' },
        'Svenska' : { DSM:'DSM-5', Sommeil:'Sömn',    Psych:'Psych', Neurology:'Neurologi', MedGle:'Allmänt Med' }
      }[currentLang] || {};
      for (let i=0;i<sel.options.length;i++){
        const o=sel.options[i]; const v=(o.value||'').trim();
        if(map[v]) o.text = map[v] + (disabledForms.includes(v) ? " (" + messagesInterface[currentLang].unavailable + ")" : "");
      }
    }catch(_){}
  }
  // ─────────────────────────────────────────────────────────
  // AJOUT : mettre à jour tous les libellés selon la langue (UpdateInterfaceLangue)
  // ─────────────────────────────────────────────────────────
  function updateInterfaceLang() {
document.documentElement.setAttribute(
  "lang",
  ({ Svenska: "sv", Français: "fr", English: "en" }[currentLang]) || "en"
);
    const m = (messagesInterface && messagesInterface[currentLang]) || messagesInterface["Français"];
    refreshInstructionBanner();
// ... à la fin de updateInterfaceLang()
try { onUILanguageChanged(); } catch(_){}
    // Accueil
     // Titre de la page d'intro (h2)
const introH2 = document.querySelector('#introScreen h2');
if (introH2) introH2.textContent = m.introTitle || 'Introduction';
    const h2 = document.querySelector('#menuScreen h2'); if (h2) h2.textContent = m.menuTitle;
    const labQ = document.querySelector('label[for="questionnaireSelect"]'); if (labQ) labQ.textContent = m.labelQuestionnaire;
    const labL = document.querySelector('label[for="langSelect"]'); if (labL) labL.textContent = m.labelLangue;
    const nextBtn = document.getElementById("nextLangBtn"); if (nextBtn) nextBtn.textContent = m.continuer;
    // Intro
    const lblCode = document.getElementById("labelCode"); if (lblCode) lblCode.textContent = m.codeLabel;
    const startBtn = document.getElementById("startBtn"); if (startBtn) startBtn.textContent = m.start;
    const introP = document.getElementById("introText"); if (introP && introP.textContent.trim()==="") introP.textContent = m.intro;
    // Main
    const validerBtn = document.getElementById("validerBtn"); if (validerBtn) validerBtn.textContent = m.valider;
    const corrigerBtn = document.getElementById("corrigerBtn"); if (corrigerBtn) corrigerBtn.textContent = m.corriger;
    const pauseBtn = document.getElementById("pauseBtn"); if (pauseBtn) pauseBtn.textContent = m.pause;
    // TTS + micro
    updateTTSBtn();
    const voiceBtn = document.getElementById("voiceBtn");
    if (voiceBtn) voiceBtn.textContent = (typeof listening!=="undefined" && listening) ? m.microOn : m.microOff;
    // fin
    const globalComment = document.getElementById("globalComment");
    if (globalComment) globalComment.placeholder = m.globalCommentPlaceholder || "";
    // fin
    const sendBtn = document.getElementById("sendToCodicentBtn");
    if (sendBtn) sendBtn.textContent = m.sendForAnalysis || "Send for analysis";
    // Bouton d'envoi (i18n)
    localizeSendButton();
  // Force Swedish label if active language is Svenska
  try {
    var sbf = document.getElementById('sendToCodicentBtn');
    if (sbf && currentLang === 'Svenska') {
      sbf.textContent = "Skicka för analys";
    }
  } catch(_){}
    // Titre
    updateHeaderBar();
  // Force Swedish label if active language is Svenska
  try {
    var sbf = document.getElementById('sendToCodicentBtn');
    if (sbf && currentLang === 'Svenska') {
      sbf.textContent = "Skicka för analys";
    }
  } catch(_){}
  }
  // ─────────────────────────────────────────────────────────
  // TTS
  // ─────────────────────────────────────────────────────────
// ===== TTS — bloc unique (PC / Samsung) =====
// Une seule déclaration dans tout le fichier :
var TTS_STORE_KEY = "ttsVoiceNameByLangCode";
var ttsVoiceNameByLang = {};
// 1) Langue courante -> code normalisé via window.currentLang ("Svenska"/"Français"/"English")
function getCurrentLangCode(){
  var txt = (window.currentLang || "").toLowerCase();
  if (txt.includes("sv")) return "sv-SE";
  if (txt.includes("en")) return "en-US";
  if (txt.includes("fr")) return "fr-FR";
  return "fr-FR";
}
// 2) Store
(function(){
  try{ ttsVoiceNameByLang = JSON.parse(localStorage.getItem(TTS_STORE_KEY) || "{}"); }
  catch(_){ ttsVoiceNameByLang = {}; }
})();
function tts_saveStore(){
  try{ localStorage.setItem(TTS_STORE_KEY, JSON.stringify(ttsVoiceNameByLang)); }catch(_){}
}
// 5) Récup voix choisie
function tts_getSelectedVoice(){
  var sel = document.getElementById("voiceSelect");
  var name = sel && sel.value;
  return name ? (__voices||[]).find(v => v.name === name) || null : null;
}
// 6) Charger/rafraîchir les voix
function tts_loadVoices(){
  try{ __voices = synth ? (synth.getVoices() || []) : []; }catch(_){ __voices = []; }
  if (typeof tts_populateVoiceSelect==='function'){ tts_populateVoiceSelect(); }
}
if (typeof speechSynthesis !== "undefined"){
  setTimeout(tts_loadVoices, 0);
  setTimeout(tts_loadVoices, 600); // Android/Chrome charge parfois en retard
}
// 7) Brancher l’UI + synchroniser currentLang avec le menu langue (id="langSelect")
document.addEventListener("DOMContentLoaded", function(){
  // sécurise currentLang au démarrage
  window.currentLang = window.currentLang || "Français";
  var langSelect = document.getElementById("langSelect"); // <-- donne cet id à ton menu Langue
  if (langSelect){
    // init
    window.currentLang = langSelect.value || langSelect.options[langSelect.selectedIndex]?.text || window.currentLang;
    onUILanguageChanged();
    // changement
    langSelect.addEventListener("change", function(){
      window.currentLang = langSelect.value || langSelect.options[langSelect.selectedIndex]?.text || "Français";
      onUILanguageChanged();
    });
  }
  var sel = document.getElementById("voiceSelect");
  if (sel){
    sel.addEventListener("change", function(){
      var key = getCurrentLangCode().substring(0,2).toUpperCase();
      ttsVoiceNameByLang[key] = sel.value || "";
      tts_saveStore();
    });
  }
  var testBtn = document.getElementById("testVoiceBtn");
  if (testBtn){
    testBtn.addEventListener("click", function(){
      var code = getCurrentLangCode();
      var sample = code.startsWith("sv") ? "Det här är ett rösttest."
                 : code.startsWith("en") ? "This is a voice test."
                 : "Ceci est un test de voix.";
      tts_testSpeak(sample);
    });
  }
  // force un premier chargement
  tts_loadVoices();
});
// 8) Test voix (débloque Android/Chrome)
function tts_testSpeak(text){
  if (!synth || !text) return;
  try{
    var u = new SpeechSynthesisUtterance(text);
    u.lang = getCurrentLangCode();
    var v = tts_getSelectedVoice(); if (v) u.voice = v;
    u.rate = 1.0; u.pitch = 1.0;
    synth.cancel(); synth.speak(u);
  }catch(_){}
}
// 9) À appeler quand ta logique change window.currentLang
function onUILanguageChanged(){
  try { if (typeof tts_populateVoiceSelect==='function'){ tts_populateVoiceSelect(); } } catch(_){}
}
  // ─────────────────────────────────────────────────────────
  // RECONNAISSANCE VOCALE (HTTPS, pas d’auto-start)
  // ─────────────────────────────────────────────────────────
  function setRecognitionLang(){
    if(!recognition) return;
    recognition.lang=(currentLang==="English")?"en-US":(currentLang==="Svenska")?"sv-SE":"fr-FR";
  }
  function initRecognition(){
    window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const ms = document.getElementById("microStatus");
    if(!window.SpeechRecognition){
      if(ms) ms.textContent = (currentLang==="English")?"🎤 Not supported":"🎤 Non supporté";
      return;
    }
    if(!window.isSecureContext && location.hostname!=="localhost"){
      if(ms) ms.textContent=(currentLang==="English")?"🎤 HTTPS required":"🎤 HTTPS requis";
      return;
    }
    recognition = new window.SpeechRecognition();
    setRecognitionLang();
    recognition.continuous=true; recognition.interimResults=false;
    recognition.onstart = ()=>{
      listening=true;
      document.getElementById("microStatus").textContent=messagesInterface[currentLang].microOn;
      document.getElementById("voiceBtn").textContent=messagesInterface[currentLang].microOn;
      document.getElementById("microStatus").style.color="green";
    };
    recognition.onend   = ()=>{
      listening=false;
      document.getElementById("microStatus").textContent=messagesInterface[currentLang].microOff;
      document.getElementById("voiceBtn").textContent=messagesInterface[currentLang].microOff;
      document.getElementById("microStatus").style.color="red";
    };
    recognition.onerror = (e)=>{
      listening=false;
      const err = e && e.error;
      if (err === "no-speech"){
        showNoSpeech();
      } else {
        const ms = document.getElementById("microStatus");
        if (ms){
          let msg = "🎤 Erreur";
          if (err==="not-allowed"||err==="service-not-allowed") msg = messagesInterface[currentLang].permDenied || "🎤 Behörighet nekad (activez le micro)";
          else if (err==="audio-capture") msg = messagesInterface[currentLang].audioCapture || "🎤 Micro non détecté";
          else if (err==="no-speech")     msg = messagesInterface[currentLang].noSpeech || "🎤 Pas de voix détectée";
          ms.textContent = msg;
        }
      }
      document.getElementById("voiceBtn").textContent=messagesInterface[currentLang].microOff;
    };
    recognition.onresult=(e)=>{
      try{
        let base = e.results[e.results.length-1];
        if (!base || !base[0] || !base[0].transcript){ showNoSpeech(); return; }
        let txt=String(base[0].transcript).toLowerCase().trim();
        txt=txt.replace(/\b(un|une|deux|trois|quatre|one|two|three|four|ett|två|tva|tre|fyra)\b/g,m=>mapChiffres[m]||m);
        if(txt.includes("stop")||txt.includes("slut")){
          txt=txt.replace(/(?:stop|slut)/gi,"").trim();
          document.getElementById("answerInput").value=txt;
          validateAnswer();
        }else{
          document.getElementById("answerInput").value=txt;
        }
      }catch(_){}
    };
  }
  /* (disabled by patch) original voiceBtn onclick was here */
  // ─────────────────────────────────────────────────────────
  // AFFICHAGE DE LA QUESTION COURANTE
  // ─────────────────────────────────────────────────────────
// ─── MODIF (GPT): reconnaissance d'un "NON" pour questions skip (inclut "1") ───
function isNoForSkip(raw){
  try{
    const s = String(raw || "").trim().toLowerCase();
    return /^(?:n|no|non|nej|nein|1)$/i.test(s);
  }catch(_){ return false; }
}
function showQuestion(){
  // --- Hard override: if a forced index is set, use it and clear the flag
  if (typeof window.__forceIndex === 'number' && isFinite(window.__forceIndex)){
    try{
      var __fi = Math.max(0, Math.min(window.__forceIndex|0, (questions && questions.length ? questions.length-1 : 0)));
      currentQuestion = __fi;
    }catch(_){}
    window.__forceIndex = null;
  }

  // couper le micro si actif
if (recognition && listening){
    try { recognition.abort(); } catch(_) { try { recognition.stop(); } catch(_){} }
    listening = false;
  }
  // Sécurité : si plus de questions → résumé
  if (!Array.isArray(questions) || currentQuestion >= questions.length){
    if (typeof showSummary === "function") showSummary();
    return;
  }
  const q = questions[currentQuestion] || {};
  
  // === ENSURE VISIBLE QUESTION LABELS ===
  try{
    var __q = questions[currentQuestion] || {};
    var secEl = document.getElementById("sectionNum");
    var numEl = document.getElementById("questionNum");
    var txtEl = document.getElementById("questionText");
    if (secEl) secEl.textContent = (__q && __q.section) ? ("Avsnitt " + __q.section) : "";
    if (numEl) numEl.textContent = (currentQuestion+1) + "/" + (questions ? questions.length : "");
    if (txtEl) txtEl.textContent = (__q && __q.text) ? __q.text : "";
  }catch(_){}
const m = (messagesInterface && messagesInterface[currentLang]) || messagesInterface["Français"];
  const sectionEl = document.getElementById("sectionNum");
  if (sectionEl) sectionEl.textContent = q.section ? `${m.sectionLabel} ${q.section}` : "";
  const qNumEl = document.getElementById("questionNum");
  if (qNumEl) qNumEl.textContent = `${m.questionLabel} ${(currentQuestion+1)}/${questions.length}`;
  const qTextEl = document.getElementById("questionText");
  if (qTextEl) qTextEl.innerHTML = q.text || "";
  const errEl = document.getElementById("mainErrorMsg");
  if (errEl) errEl.textContent = "";
  const scoreBox = document.getElementById("scoreContainer");
  if (scoreBox) scoreBox.style.display = "none";
// nouvau bloc pour seulement reponses SCORE 1-5

// === SCORE-ONLY (sections ≥3 + notables) : UI immédiate ===
try{
  const q = questions[currentQuestion] || {};
const isQuant =
  (q && q.type === "scale") ||
  (q && Number(q.section) >= 3 && window.NOTABLES_SET && window.NOTABLES_SET.has(currentQuestion));
const isMixed = (typeof MIXED_QUESTIONS !== "undefined") && MIXED_QUESTIONS.has(currentQuestion);
if (isQuant && !isMixed) {
  // libellé i18n pour le score
  const lbl = document.getElementById("scoreLabel");
  if (lbl){
    let txt = messagesInterface[currentLang].errorScale;
    // ─── MODIF (GPT): si la question fait partie des échelles verbales, changer le libellé ───
    try{
      if (typeof VERBAL_SCALE_QUESTIONS !== "undefined" && VERBAL_SCALE_QUESTIONS.has(currentQuestion)){
      txt = (currentQuestion===30||currentQuestion===32) ? "Välj 1–5: 1=dålig, 2=rättvis, 3=bra, 4=mycket bra, 5=utmärkt" : "Välj 1–5: 1=inte alls, 2=kanske, 3=lite, 4=ganska mycket, 5=mycket";
      }
    }catch(_){}
    lbl.textContent = txt;
  }
    // Cacher/désactiver le champ texte
    const ta = document.getElementById("answerInput");
    if (ta){ ta.value=""; ta.style.display="none"; ta.disabled=true; }
    // Ouvrir l’échelle et focus
    const sc = document.getElementById("scoreContainer"); if (sc){ sc.style.display="block"; sc.hidden=false; }
    const si = document.getElementById("scoreInput");
    if (si){
      si.min="1"; si.max="5"; si.value="";
      setTimeout(()=>{ try{ si.focus(); }catch(_){ } }, 80);
      si.onkeypress = (e)=>{ if(e.key==="Enter"){ e.preventDefault(); document.getElementById("validateScoreBtn")?.click(); } };
    }
    // Rediriger Valider → OK (score)
    const ok = document.getElementById("validateScoreBtn");
    if (ok){
      const clone = ok.cloneNode(true); ok.parentNode.replaceChild(clone, ok);
      document.getElementById("validateScoreBtn").onclick = function(){
        const v = Number((document.getElementById("scoreInput")||{}).value);
        validateAnswer(v);
      };
    }
    const mainBtn = document.getElementById("validerBtn");
    if (mainBtn){
      mainBtn.onclick = (e)=>{ e.preventDefault(); document.getElementById("validateScoreBtn")?.click(); };
    }
  }
}catch(_){}

// Fin du bloc SCORE seulement
const f = document.getElementById("answerInput");
if (f){
  f.value = "";
  const __q = questions[currentQuestion] || {};
  const __isQuant =
    (__q && __q.type === "scale") ||
    (__q && Number(__q.section) >= 3 && window.NOTABLES_SET && window.NOTABLES_SET.has(currentQuestion));

  // >>> FIX : ne pas cacher la zone texte si la question est en mode MIXTE
  const __isMixed = (typeof window.MIXED_QUESTIONS !== "undefined") && window.MIXED_QUESTIONS.has(currentQuestion);

  if (__isQuant && !__isMixed) {
    // Score-only : on reste en mode score, champ texte caché
    f.style.display = "none";
    f.disabled = true;
  } else {
    // Questions ouvertes OU mixtes (texte puis score) : texte visible
    f.style.display = "block";
    f.disabled = false;
    f.value = "";
    setTimeout(()=>{ try{ f.focus(); }catch(_){ } }, 80);
  }
}

  updateProgress();
  // 🔁 Banderole (RETUR/AVSLUTA / micro on/off) selon la langue
  if (typeof refreshInstructionBanner === "function") refreshInstructionBanner();
  // TTS
  // TTS — lit le texte; si vide et c’est une échelle, lit l’aide 1–5
var _txt = (q && q.text) ? q.text : "";
var _isScale = (q && q.type === "scale") || (window.NOTABLES_SET && window.NOTABLES_SET.has(currentQuestion));
if (!_txt && _isScale){
  var L = (typeof SCALE_LABELS !== "undefined" && SCALE_LABELS.sv) ? SCALE_LABELS.sv : null;
  _txt = L ? (L.helpPrefix + " 1–5") : "Välj 1–5";
}
if (typeof lireTexte === "function") lireTexte(_txt);
}
    // ❌ Pas d’auto-démarrage micro (évite re-prompts permission)
    // setTimeout(()=>{ if(recognition && !paused && !isMobile){ recognition.start(); listening=true; }},1200);
  // ─────────────────────────────────────────────────────────
  // VALIDATION (attend correction + échelle + skip)
  // ─────────────────────────────────────────────────────────
  function validateAnswer(extraScore=null){
if (paused){ isValidating=false; return; }
    { const _f=document.getElementById("answerInput"); const _r=((_f&&_f.value)||"").trim();
      if (justCorrected && (!_r && !extraScore)){ isValidating=false; return; } }
    if (isValidating) return; isValidating=true;
    if (typeof questions[currentQuestion]==="undefined"){ isValidating=false; return; }
    const f=document.getElementById("answerInput"); let r=(f.value||"").trim();
// ── MIXTE: forced set (text → then 1–5 scale) ──
try {
  const __isForcedMixed = (function(){

// Ici changer questions mixtes
    const set = new Set([32,36]) // Q33, Q37 (Q27 removed: NOTABLE-only); // 0-based indices: Q27,Q33, Q37

    let idx = -1;
    if (typeof currentQuestion === 'number') idx = currentQuestion;
    else {
      try{
        var el=document.getElementById('questionNum');
        if(el){ var m=el.textContent.match(/(\d+)\s*\/\s*(\d+)/); if(m) idx=parseInt(m[1],10)-1; }
      }catch(_){ idx = -1; }
    }
    return set.has(idx);
  })();
  if (__isForcedMixed) {if (extraScore === null) {
      if (!r) {
        isValidating = false;
        const err = document.getElementById("mainErrorMsg");
        if (err){ err.textContent = "⚠️ Skriv ett svar eller diktera SLUT"; setTimeout(()=>err.textContent="", 1800); }
        return;
      }
      const sc = document.getElementById("scoreContainer");
      const si = document.getElementById("scoreInput");
      if (sc){ sc.style.display = "block"; sc.hidden = false; }
      if (si){
        si.min = "1"; si.max = "5"; si.value = "";
        setTimeout(()=>{ try{ si.focus(); }catch(_){ } }, 60);
        const onEnter = (e)=>{ if(e.key === "Enter"){ e.preventDefault(); document.getElementById("validateScoreBtn")?.click(); si.removeEventListener("keypress", onEnter); } };
        si.addEventListener("keypress", onEnter);
      }
      const ok = document.getElementById("validateScoreBtn");
      if (ok){
        ok.replaceWith(ok.cloneNode(true));
        document.getElementById("validateScoreBtn").onclick = function(){
          const v = Number((document.getElementById("scoreInput")||{}).value);
          validateAnswer(v);
        };
      }
      isValidating = false;
      return;
    }
    // Temps 2: on a un score -> continuer (option: concaténer au texte)
    r = r ? (r + " - " + String(extraScore)) : String(extraScore);
  }
} catch(_) {}
// ─── MODIF (GPT v3): SkipIfNon robuste + reset UI ───
try{
  const qSK = questions[currentQuestion] || {};
  const a_txt = (r||"").trim().toLowerCase();
  const a_num = (extraScore!==null && extraScore!==undefined) ? Number(extraScore) : null;
  if (qSK && qSK.skipIfNon && ( (typeof isNoForSkip==="function" && isNoForSkip(a_txt)) || a_num === 1 )){
    answers[currentQuestion] = r || (a_num!=null ? String(a_num) : "(sans réponse)");
    const sectionActuelle__ = qSK.section;
    let next__ = currentQuestion + 1;
    while(next__ < questions.length && questions[next__].section === sectionActuelle__) next__++;
    const tSkip__ = Math.max(
      config.tempsBaseReponse + (r ? r.length : 0)*config.tempsParCaractere,
      (config.minDelaySkip || 1200)
    );
    // Reset now to avoid stuck state, then jump after delay
    try{
      isValidating=false; paused=false;
      const sc = document.getElementById("scoreContainer"); if (sc){ sc.style.display="none"; sc.hidden=true; }
      const si = document.getElementById("scoreInput"); if (si){ si.value=""; si.disabled=false; si.style.display=""; }
      const ta = document.getElementById("answerInput"); if (ta){ ta.disabled=false; ta.style.display=""; }
      document.getElementById("mainErrorMsg").textContent="";
    }catch(_){}
    setTimeout(()=>{
      if(justCorrected){ isValidating=false; return; }
      currentQuestion = next__;
      if (currentQuestion < questions.length)  { showQuestion(); try{ var nq=questions[currentQuestion]||{}; var t=nq.text||""; var isScale=(nq.type==="scale")||(window.NOTABLES_SET&&window.NOTABLES_SET.has(currentQuestion)); if(!t&&isScale){ var L=(typeof SCALE_LABELS!=="undefined"&&SCALE_LABELS.sv)?SCALE_LABELS.sv:null; t=L?(L.helpPrefix+" 1–5"):"Välj 1–5"; } if(window.ttsEnabled&&typeof lireTexte==="function") lireTexte(t); }catch(_){ } } else showSummary();
    }, tSkip__);
    return;
  }
}catch(_){}
// ─── MODIF (GPT): SkipIfNon robuste (texte "1" OU extraScore==1), avant toute autre logique ───
try{
  const qSK = questions[currentQuestion] || {};
  const a_txt = (r||"").trim().toLowerCase();
  const a_num = (extraScore!==null && extraScore!==undefined) ? Number(extraScore) : null;
  if (qSK && qSK.skipIfNon && ( (typeof isNoForSkip==="function" && isNoForSkip(a_txt)) || a_num === 1 )){
    answers[currentQuestion] = r || (a_num!=null ? String(a_num) : "(sans réponse)");
    const sectionActuelle__ = qSK.section;
    let next__ = currentQuestion + 1;
    while(next__ < questions.length && questions[next__].section === sectionActuelle__) next__++;
    const tSkip__ = Math.max(
      config.tempsBaseReponse + (r ? r.length : 0)*config.tempsParCaractere,
      (config.minDelaySkip || 1200)
    );
    setTimeout(()=>{
      if(justCorrected){ isValidating=false; return; }
      currentQuestion = next__;
      if (currentQuestion < questions.length)  { showQuestion(); try{ var nq=questions[currentQuestion]||{}; var t=nq.text||""; var isScale=(nq.type==="scale")||(window.NOTABLES_SET&&window.NOTABLES_SET.has(currentQuestion)); if(!t&&isScale){ var L=(typeof SCALE_LABELS!=="undefined"&&SCALE_LABELS.sv)?SCALE_LABELS.sv:null; t=L?(L.helpPrefix+" 1–5"):"Välj 1–5"; } if(window.ttsEnabled&&typeof lireTexte==="function") lireTexte(t); }catch(_){ } } else showSummary();
    }, tSkip__);
    return;
  }
}catch(_){}
if (justCorrected && (!r && !extraScore)){ isValidating=false; return; }
    justCorrected=false;
// Changement pour seulement reponses SCORE 1-5
    //if (!r && !extraScore){
    //  isValidating=false;
    //  document.getElementById("mainErrorMsg").textContent="⚠️ Skriv ett svar eller //diktera SLUT";
     // setTimeout(()=>document.getElementById("mainErrorMsg").textContent="",2000);
     // return;
    //}
if (!r && !extraScore){
  const q = questions[currentQuestion] || {};
  const isQuant = q && Number(q.section) >= 3 && window.NOTABLES_SET && window.NOTABLES_SET.has(currentQuestion);
  if (isQuant){
    // Ouvrir l’échelle 1–5 immédiatement (pas de texte requis)
    const sc = document.getElementById("scoreContainer"); if (sc){ sc.style.display="block"; sc.hidden=false; }
    const si = document.getElementById("scoreInput");
    if (si){
      si.min="1"; si.max="5"; si.value="";
      setTimeout(()=>{ try{ si.focus(); }catch(_){ } }, 80);
      si.onkeypress = (e)=>{ if(e.key==="Enter"){ e.preventDefault(); document.getElementById("validateScoreBtn")?.click(); } };
    }
    // Valider/Entrée → OK
    const ok = document.getElementById("validateScoreBtn");
    if (ok){
      const clone = ok.cloneNode(true); ok.parentNode.replaceChild(clone, ok);
      document.getElementById("validateScoreBtn").onclick = function(){
        const v = Number((document.getElementById("scoreInput")||{}).value);
        validateAnswer(v);
      };
    }
    // Cacher/désactiver la zone texte
    const ta = document.getElementById("answerInput");
    if (ta){ ta.value=""; ta.style.display="none"; ta.disabled=true; }
    isValidating=false;
    return; // en quantitatif, on n’exige PAS de texte
  }
  // Non-quantitatif → logique d’origine
  isValidating=false;
  document.getElementById("mainErrorMsg").textContent="⚠️ Skriv ett svar eller diktera SLUT";
  setTimeout(()=>document.getElementById("mainErrorMsg").textContent="",2000);
  return;
}
// fin du changement
// ─── MODIF (GPT): Skip NON (incl. "1") pour questions textuelles avec skipIfNon ───
try{
  const q__ = questions[currentQuestion] || {};
  const lowerResp__ = (r||"").toLowerCase();
  // Détecte "NON" (inclut "1") et saute toute la section si la question est skipIfNon et pas "scale"
  if (q__ && q__.skipIfNon && q__.type !== "scale" && isNoForSkip(lowerResp__)){
    answers[currentQuestion]=r||"(sans réponse)";
    const sectionActuelle__ = q__.section;
    let next__ = currentQuestion + 1;
    while(next__ < questions.length && questions[next__].section === sectionActuelle__) next__++;
    const tSkip__ = Math.max(
      config.tempsBaseReponse + r.length*config.tempsParCaractere,
      (config.minDelaySkip || 1200)
    );
    setTimeout(()=>{
      if(justCorrected){ isValidating=false; return; }
      currentQuestion = next__;
      if (currentQuestion < questions.length)  { showQuestion(); try{ var nq=questions[currentQuestion]||{}; var t=nq.text||""; var isScale=(nq.type==="scale")||(window.NOTABLES_SET&&window.NOTABLES_SET.has(currentQuestion)); if(!t&&isScale){ var L=(typeof SCALE_LABELS!=="undefined"&&SCALE_LABELS.sv)?SCALE_LABELS.sv:null; t=L?(L.helpPrefix+" 1–5"):"Välj 1–5"; } if(window.ttsEnabled&&typeof lireTexte==="function") lireTexte(t); }catch(_){ } } else showSummary();
    }, tSkip__);
    return;
  }
}catch(_){}
if (questions[currentQuestion].type==="scale"){
      const lowerResp=r.toLowerCase();
      // Skip section si 1re question est "non/no/nej"
      if (questions[currentQuestion].skipIfNon && (/(^|\b)(non|no|nej|n|1)(\b|$)/i).test(lowerResp)){
        answers[currentQuestion]=r||"(sans réponse)";
        const sectionActuelle=questions[currentQuestion].section;
        let next=currentQuestion+1;
        while(next<questions.length && questions[next].section===sectionActuelle) next++;
const tSkip = Math.max(
  config.tempsBaseReponse + r.length*config.tempsParCaractere,
  config.minDelaySkip
);
        setTimeout(()=>{ if(justCorrected){ isValidating=false; return; } currentQuestion=next; isValidating=false; if (currentQuestion < questions.length)  { showQuestion(); try{ var nq=questions[currentQuestion]||{}; var t=nq.text||""; var isScale=(nq.type==="scale")||(window.NOTABLES_SET&&window.NOTABLES_SET.has(currentQuestion)); if(!t&&isScale){ var L=(typeof SCALE_LABELS!=="undefined"&&SCALE_LABELS.sv)?SCALE_LABELS.sv:null; t=L?(L.helpPrefix+" 1–5"):"Välj 1–5"; } if(window.ttsEnabled&&typeof lireTexte==="function") lireTexte(t); }catch(_){ } } else showSummary(); }, tSkip);
        return;
      }
      // "non" simple -> avancer
      if ((/(^|\b)(non|no|nej|n|1)(\b|$)/i).test(lowerResp)){
        answers[currentQuestion]=r||"(sans réponse)";
        let t=Math.min(config.tempsBaseReponse + r.length*config.tempsParCaractere, config.tempsMaxReponse);
     // Temps d'attente apres RETOUR avant de passer a la question suivante pour donner le temps de corriger ici 2000 = 2 sec 
	//t=Math.max(t,2000);
      t = Math.max(t, config.minDelayNo);
        setTimeout(()=>{ if(justCorrected){ isValidating=false; return; } currentQuestion++; isValidating=false; if (currentQuestion < questions.length)  { showQuestion(); try{ var nq=questions[currentQuestion]||{}; var t=nq.text||""; var isScale=(nq.type==="scale")||(window.NOTABLES_SET&&window.NOTABLES_SET.has(currentQuestion)); if(!t&&isScale){ var L=(typeof SCALE_LABELS!=="undefined"&&SCALE_LABELS.sv)?SCALE_LABELS.sv:null; t=L?(L.helpPrefix+" 1–5"):"Välj 1–5"; } if(window.ttsEnabled&&typeof lireTexte==="function") lireTexte(t); }catch(_){ } } else showSummary(); }, t);
        return;
      }
      // Demander score si absent
      let score=extraScore;
      if(!score){
        const sc=document.getElementById("scoreContainer"); sc.style.display="block";
(function(){
  var lblEl = document.getElementById("scoreLabel");
  var txt = (messagesInterface && messagesInterface[currentLang] ? messagesInterface[currentLang].errorScale : "");
  // ─── MODIF (GPT): libellé spécial pour les questions à échelle verbale ───
  try{
    if (typeof VERBAL_SCALE_QUESTIONS !== "undefined" && VERBAL_SCALE_QUESTIONS.has(currentQuestion)){
      txt = (currentQuestion===30||currentQuestion===32) ? "Välj 1–5: 1=dålig, 2=rättvis, 3=bra, 4=mycket bra, 5=utmärkt" : "Välj 1–5: 1=inte alls, 2=kanske, 3=lite, 4=ganska mycket, 5=mycket";
    }
  }catch(_){}
  if (lblEl) lblEl.textContent = txt;
        try{ __applySwedishLabelsForCurrent(); }catch(_){}
})();
document.getElementById("mainErrorMsg").textContent="";
        const scoreInput=document.getElementById("scoreInput");
        scoreInput.min="1"; scoreInput.max="5"; scoreInput.value="";
        setTimeout(()=>scoreInput.focus(),100);
        const handler=(e)=>{ if(e.key==="Enter"){ e.preventDefault(); document.getElementById("validateScoreBtn").click(); scoreInput.removeEventListener("keypress",handler);} };
        scoreInput.addEventListener("keypress",handler);
        if (recognition && listening){
          recognition.onresult=(e)=>{
            let txt=e.results[e.results.length-1][0].transcript.toLowerCase().trim();
            txt=txt.replace(/\b(un|une|deux|trois|quatre|one|two|three|four|ett|två|tva|tre|fyra)\b/g,m=>mapChiffres[m]||m);
            if (/(?:stop|slut)/.test(txt)){
              let chiffre=txt.replace(/(?:stop|slut)/gi,"").trim();
              if(chiffre && !isNaN(chiffre) && chiffre>=1 && chiffre<=5){ document.getElementById("scoreInput").value=chiffre; document.getElementById("validateScoreBtn").click(); }
            }
          };
        }
        const btn=document.getElementById("validateScoreBtn");
        btn.replaceWith(btn.cloneNode(true)); // reset listeners
        document.getElementById("validateScoreBtn").onclick=()=>{
          const entered=document.getElementById("scoreInput").value;
//     Erreur si notable <1 ou > 5
          if(!entered || isNaN(entered) || entered<1 || entered>5){
            jouerBipErreur();
            try{ document.getElementById("scoreInput").style.borderColor="red"; setTimeout(()=>{ document.getElementById("scoreInput").style.borderColor=""; },600);}catch(_){}
            return;
          }
          document.getElementById("scoreContainer").style.display="none";
          validateAnswer(entered);
        };
        isValidating=false; return;
      }
      r = r ? (r+" - "+score) : score;
    }
    answers[currentQuestion]=r||"(sans réponse)";
    let t=Math.min(config.tempsBaseReponse + r.length*config.tempsParCaractere, config.tempsMaxReponse);
t = Math.max(t, config.minDelayDefault);
    setTimeout(()=>{ if(justCorrected){ isValidating=false; return; } currentQuestion++; isValidating=false; if (currentQuestion < questions.length)  { showQuestion(); try{ var nq=questions[currentQuestion]||{}; var t=nq.text||""; var isScale=(nq.type==="scale")||(window.NOTABLES_SET&&window.NOTABLES_SET.has(currentQuestion)); if(!t&&isScale){ var L=(typeof SCALE_LABELS!=="undefined"&&SCALE_LABELS.sv)?SCALE_LABELS.sv:null; t=L?(L.helpPrefix+" 1–5"):"Välj 1–5"; } if(window.ttsEnabled&&typeof lireTexte==="function") lireTexte(t); }catch(_){ } } else showSummary(); }, t);
  }
  // ─────────────────────────────────────────────────────────
  // BOUTONS (valider, corriger, pause, export)
  // ─────────────────────────────────────────────────────────
  document.getElementById("validerBtn").onclick = validateAnswer;
  document.getElementById("answerInput").addEventListener("keydown", e=>{
    if(e.key==="Enter" && !e.shiftKey){ e.preventDefault(); validateAnswer(); }
  });
  document.getElementById("corrigerBtn").onclick = ()=>{
    const f=document.getElementById("answerInput"); f.value="";
    const sc=document.getElementById("scoreContainer"); if(sc){ sc.style.display="none"; document.getElementById("scoreInput").value=""; }
    if (recognition && listening){ try{ recognition.abort(); }catch(_){ recognition.stop(); } listening=false; }
    justCorrected=true; setTimeout(()=>f.focus(),100);
    const err=document.getElementById("mainErrorMsg"); err.textContent=(messagesInterface[currentLang] && messagesInterface[currentLang].alertRewrite) || "Réécrivez votre réponse"; setTimeout(()=>err.textContent="",4000);
  };
  document.getElementById("pauseBtn").onclick = ()=>{
    if(!paused){
      localStorage.setItem("QSM_"+userCode, JSON.stringify({answers,currentQuestion}));
      document.getElementById("pauseBtn").textContent = messagesInterface[currentLang].reprendre;
      paused=true; if(recognition && listening){ try{ recognition.abort(); }catch(_){ recognition.stop(); } listening=false; }
    }else{
      paused=false; document.getElementById("pauseBtn").textContent = messagesInterface[currentLang].pause;
      const saved=localStorage.getItem("QSM_"+userCode);
      if(saved){ const d=JSON.parse(saved); answers=d.answers||[]; currentQuestion=d.currentQuestion||0; }
      showQuestion();
    }
  };
  function showSummary(){
    document.getElementById("main").style.display="none";
    document.getElementById("summary").style.display="block";
    document.getElementById("resumeCode").textContent=userCode;
    const ul=document.getElementById("answersList"); ul.innerHTML="";
    questions.forEach((q,i)=>{
      const li=document.createElement("li");
      li.innerHTML=`<b>${q.text}</b><br><textarea class='editable' onchange='answers[${i}]=this.value'>${answers[i]||''}</textarea>`;
      ul.appendChild(li);
    });
    lireTexte(messagesInterface[currentLang].summaryTitle);
    // i18n right after summary appears
    setSendBtnLabel();
    setTimeout(setSendBtnLabel, 50);
    setTimeout(setSendBtnLabel, 200);
// Localize Codicent send button when summary becomes visible
    try {
      const m = (window.messagesInterface && window.messagesInterface[currentLang]) || {};
      const sendBtn = document.getElementById("sendToCodicentBtn");
      if (sendBtn) sendBtn.textContent = m.sendForAnalysis || "Send for analysis";
    } catch(_) {}
}
  document.getElementById("pdfBtn").onclick=()=>{
    let txt="Code: "+userCode+"\n";
    questions.forEach((q,i)=>{ txt+=`${i+1}. ${q.text}\nRéponse: ${answers[i]||''}\n\n`; });
    const w=window.open('','_blank'); if(w){ w.document.write('<pre>'+txt+'</pre>'); w.print(); }
  };
// terminer: demande de nom de fichier et sauvegarde
  document.getElementById("copyBtn").onclick=()=>{
    let txt="Code: "+userCode+"\n";
    questions.forEach((q,i)=>{ txt+=`${i+1}. ${q.text}: ${answers[i]||''}\n`; });
    const blob=new Blob([txt],{type:'text/plain'});
    const link=document.createElement('a'); link.href=URL.createObjectURL(blob); link.download="Réponses_Questionnaire_"+userCode+".txt"; link.click();
  };
// -----------------------
// AVSLUTA
document.getElementById("closeBtn").onclick = () => {
  const filename = prompt(
    messagesInterface[currentLang].promptFilename,
    (messagesInterface[currentLang].defaultFilename || "Formulär_Svar_") + userCode + ".txt"
  );
  if (!filename) return;
  // 1) Construire le contenu
  let txt = "Code: " + userCode + "\n";
  questions.forEach((q, i) => {
    txt += `${i + 1}. ${q.text}\nRéponse: ${answers[i] || ""}\n\n`;
  });
  // 2) Télécharger le .txt
  const blob = new Blob([txt], { type: "text/plain" });
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement("a");
  a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
  // 3) Écran final + ENTER pour fermer (SV/FR/EN)
const finalLang   = (["Svenska","Français","English"].includes(currentLang)) ? currentLang : "English";
const finalFolder = { Svenska: "Hämtade filer", Français: "Téléchargements", English: "Downloads" }[finalLang];
const finalTexts  = {
  Svenska: {
    screen: `Tack! Dina svar har sparats i mappen ${finalFolder}.<br><br>Du kan nu stänga fönstret.`,
    hint:   'Tryck RETUR för att stänga fliken.',
    block:  'Automatisk stängning blockerad. Tryck Ctrl+W (Cmd+W på Mac) eller Alt+F4.'
  },
  Français: {
    screen: `Merci ! Vos réponses ont été enregistrées dans le dossier ${finalFolder}.<br><br>Vous pouvez maintenant fermer la fenêtre.`,
    hint:   'Appuyez sur ENTRÉE pour fermer l’onglet.',
    block:  'Fermeture auto bloquée. Appuyez sur Ctrl+W (Cmd+W sur Mac) ou Alt+F4.'
  },
  English: {
    screen: `Thanks! Your answers have been saved in the ${finalFolder} folder.<br><br>You can now close this window.`,
    hint:   'Press ENTER to close the tab.',
    block:  'Auto-close blocked. Press Ctrl+W (Cmd+W on Mac) or Alt+F4.'
  }
}[finalLang];
// Rendu de l’écran final
document.body.innerHTML = `
  <div id="finalScreen" style="text-align:center; margin-top:50px; font-size:1.5em;">
    ${finalTexts.screen}
    <div id="closeHint" style="margin-top:16px; font-size:1rem; opacity:.8;">${finalTexts.hint}</div>
  </div>
`;
// Détection “ouvert par script” ou via lanceur (optionnel: ?spawned=1)
const spawned = (() => {
  try { return new URLSearchParams(location.search).get('spawned') === '1'; } catch(_) { return false; }
})();
// Tentative de fermeture
function attemptCloseOnce(){
  try {
    // Cas OK: fenêtre enfant ouverte par script (ou marquée spawned)
    if ((window.opener && !window.opener.closed) || spawned) { window.close(); return true; }
    // Cas navigation interne: revenir en arrière
    if (history.length > 1) { history.back(); return true; }
    // Dernier essai (souvent bloqué)
    window.open('', '_self'); window.close();
  } catch(_) {}
  return false;
}
// ENTER / NUMPAD-ENTER — feedback immédiat si bloqué
function onCloseKey(e){
  const k = e.key;
  if (k !== 'Enter' && k !== 'NumpadEnter') return;
  e.preventDefault();
  const ok = attemptCloseOnce();
  if (!ok) {
    const hint = document.getElementById('closeHint');
    if (hint) {
      hint.textContent = finalTexts.block;
      hint.style.opacity = '1';
      hint.style.fontWeight = '700';
    }
  }
}
document.addEventListener('keydown', onCloseKey, { capture: true });
// Click sur l’écran final: même logique (fermer ou afficher l’instruction)
document.getElementById('finalScreen').addEventListener('click', () => {
  const ok = attemptCloseOnce();
  if (!ok) {
    const hint = document.getElementById('closeHint');
    if (hint) {
      hint.textContent = finalTexts.block;
      hint.style.opacity = '1';
      hint.style.fontWeight = '700';
    }
  }
}, { once: false });
}; // <-- FIN de closeBtn.onclick
// --------------------------
  /* Ensure Codicent button exists */
  document.addEventListener('DOMContentLoaded', function(){
    try{
      var summary = document.getElementById('summary');
      if (!summary) return;
      var btn = document.getElementById('sendToCodicentBtn');
      var pdfBtn = document.getElementById('pdfBtn');
      if (!btn && pdfBtn){
        btn = document.createElement('button');
        btn.id = 'sendToCodicentBtn';
        // Default label; will be localized by updateInterfaceLang if present
        var m = (window.messagesInterface && window.messagesInterface[window.currentLang]) || {};
        btn.textContent = (m && m.sendForAnalysis) || 'Send for analysis';
        pdfBtn.insertAdjacentElement('afterend', btn);
      }
      var status = document.getElementById('codicentStatus');
      if (!status){
        status = document.createElement('div');
        status.id = 'codicentStatus';
        status.style.display = 'none';
        status.style.marginTop = '8px';
        status.style.fontWeight = '600';
        (btn || pdfBtn).insertAdjacentElement('afterend', status);
      }
    }catch(e){ console.warn('Codicent button ensure failed:', e); }
  });
  // === Helper: localize the Codicent send button according to currentLang ===
  function localizeSendButton(){
    try{
      var m = (window.messagesInterface && window.messagesInterface[currentLang]) || {};
      var sb = document.getElementById('sendToCodicentBtn');
      if (sb) sb.textContent = (m && m.sendForAnalysis) || 'Send for analysis';
    }catch(_){}
  }
  // Strong i18n setter for the Codicent send button (with fallbacks)
  function setSendBtnLabel(){
    try{
      var L = window.currentLang || 'Français';
      var m = (window.messagesInterface && window.messagesInterface[L]) || {};
      var b = document.getElementById('sendToCodicentBtn');
      if (!b) return;
      var fallback = (L==='Svenska') ? 'Skicka för analys' : (L==='Français' ? 'Envoyer pour analyse' : 'Send for analysis');
      b.textContent = m.sendForAnalysis || fallback;
    }catch(_){}
  }
  // === CODICENT – Token, préparation du contenu et envoi ===
  // Récupère le token depuis l'URL (?token=...)
  function getCodicentToken(){
    try{
      const p = new URLSearchParams(location.search);
      return p.get('token') || null;
    }catch(_){ return null; }
  }
  // Construit le message à envoyer (Q/R + code + commentaire)
  function prepareMessageContent(){
    let content = `Form Data:
`;
    const formCode = document.getElementById('codeInput')?.value || userCode || "";
    if (formCode) content += `Code: ${formCode}
`;
    (questions || []).forEach((q, i) => {
      content += `${i+1}. ${q.text || ""}
`;
      content += `Answer: ${answers[i] || ""}
`;
    });
    const globalComment = document.getElementById('globalComment')?.value?.trim();
    if (globalComment) content += `Comments: ${globalComment}
`;
    // Tag projet (à adapter si nécessaire)
    return `@swedsleep_demo #profile ${content}`;
  }
  // Gestion du clic sur le bouton "Envoyer pour analyse"
  document.addEventListener('DOMContentLoaded', function(){
    const btn = document.getElementById('sendToCodicentBtn');
    const statusDiv = document.getElementById('codicentStatus');
    if (!btn) return;
    btn.addEventListener('click', async function(){
      try{
        const token = getCodicentToken();
        if (!token){
          if (statusDiv){ statusDiv.style.display='block'; statusDiv.style.color='red'; statusDiv.textContent = (messagesInterface?.[currentLang]?.noTokenMsg) || 'No ?token parameter found in URL.'; }
          return;
        }
        // Init Codicent
        try { window.Codicent && window.Codicent.init({ token, maxConnectionAttempts: 3 }); } catch(e){ /* ignore init errors here */ }
        const message = prepareMessageContent();
        const id = await (window.Codicent && window.Codicent.postMessage ? window.Codicent.postMessage({ message }) : Promise.reject(new Error('CodicentJS not loaded')));
        if (statusDiv){ statusDiv.style.display='block'; statusDiv.style.color='green'; statusDiv.textContent = (messagesInterface?.[currentLang]?.codicentSuccessPrefix || 'Sent to Codicent: ') + id; }
      }catch(e){
        if (statusDiv){ statusDiv.style.display='block'; statusDiv.style.color='red'; statusDiv.textContent = (messagesInterface?.[currentLang]?.codicentErrorPrefix || 'Error: ') + (e?.message || e); }
      }
      // Auto-hide after a few seconds
      if (statusDiv){ setTimeout(()=>{ statusDiv.style.display='none'; }, 8000); }
    });
      // Relocalize send button on language change
      try{
        var lSel = document.getElementById('langSelect');
        if (lSel){
          lSel.addEventListener('change', function(){
            var m2 = (window.messagesInterface && window.messagesInterface[window.currentLang]) || {};
            var sb = document.getElementById('sendToCodicentBtn');
            if (sb) sb.textContent = (m2 && m2.sendForAnalysis) || 'Send for analysis';
          });
        }
      }catch(_){}
  });
  // ─────────────────────────────────────────────────────────
  // NAVIGATION + INIT SÛRE
  // ─────────────────────────────────────────────────────────
  function startQuestionnaire(){
    const selectedQ=document.getElementById("questionnaireSelect").value;
    if (Array.isArray(disabledForms) && disabledForms.includes(selectedQ)){
      document.getElementById("menuError").textContent = messagesInterface[currentLang].alertOption;
      try{ jouerBipErreur(); }catch(_){}
      alert(messagesInterface[currentLang].alertOption); return;
    }
    userCode=(document.getElementById("codeInput").value||"").trim();
    if (userCode.length!==4 || isNaN(userCode)){
      document.getElementById("introErrorMsg").textContent = messagesInterface[currentLang].errorCode;
      jouerBipErreur(); return;
    }
    answers=[]; currentQuestion=0; localStorage.removeItem("QSM_"+userCode);
    document.getElementById("introScreen").style.display="none";
    document.getElementById("main").style.display="block";
    showQuestion();
    refreshInstructionBanner();
  }
  document.addEventListener("DOMContentLoaded", () => {
    try{ setSendBtnLabel(); }catch(_){ }
    /* Localize send button on DOMContentLoaded */
    try{ const m0=(window.messagesInterface&&window.messagesInterface[currentLang])||{}; const sb0=document.getElementById("sendToCodicentBtn"); if (sb0) sb0.textContent=m0.sendForAnalysis||"Send for analysis"; }catch(_){}
    // Bouton d'envoi (i18n)
    localizeSendButton();
  // Force Swedish label if active language is Svenska
  try {
    var sbf = document.getElementById('sendToCodicentBtn');
    if (sbf && currentLang === 'Svenska') {
      sbf.textContent = "Skicka för analys";
    }
  } catch(_){}
    // Titre
    updateHeaderBar();
  // Force Swedish label if active language is Svenska
  try {
    var sbf = document.getElementById('sendToCodicentBtn');
    if (sbf && currentLang === 'Svenska') {
      sbf.textContent = "Skicka för analys";
    }
  } catch(_){}
    // Remplir QUESTIONNAIRES
    const qSel = document.getElementById("questionnaireSelect");
    if (qSel){
      qSel.innerHTML =
        '<option value="DSM">DSM-5</option>'+
        '<option value="Sommeil">Sommeil</option>'+
        '<option value="Psych">Psych</option>'+
        '<option value="Neurology">Neurologie</option>'+
        '<option value="MedGle">Med Gle</option>';
      for(let i=0;i<qSel.options.length;i++){ const o=qSel.options[i]; if(disabledForms.includes(o.value)){ o.text = o.text + " (" + messagesInterface[currentLang].unavailable + ")"; } }
      qSel.onchange = function(){
        const val=this.value;
        if(disabledForms.includes(val)){
          const el=document.getElementById("menuError"); if(el) el.textContent = messagesInterface[currentLang].alertOption;
          try{ jouerBipErreur(); }catch(_){}
        }else{
          const el=document.getElementById("menuError"); if(el) el.textContent="";
        }
      };
    }
    // Remplir LANGUES
    const lSel = document.getElementById("langSelect");
    if (lSel){
      lSel.innerHTML =
        '<option value="Français">Français</option>'+
        '<option value="English">English</option>'+
        '<option value="Svenska" selected>Svenska</option>';
      currentLang = lSel.value || "Français";
      lSel.onchange = function(){
        try{ setSendBtnLabel(); }catch(_){ }
        currentLang=this.value;
        updateInterfaceLang();
        updateQuestionnaireLabels();
      };
    }
    // Libellés init
    updateInterfaceLang();
    updateQuestionnaireLabels();
    updateTTSBtn();
    // CONTINUER -> INTRO
    const nextBtn = document.getElementById("nextLangBtn");
    if (nextBtn){
      nextBtn.onclick = function(){
        const selectedQ = (qSel && qSel.value) || "DSM";
        const allowed = (window.availableLangsByForm && window.availableLangsByForm[selectedQ]) || [];
     if (!allowed.includes(currentLang)) {
    const el = document.getElementById("menuError");
    // Message en suédois, comme demandé
    const seulement = (window.messagesInterfaceOverrides && window.messagesInterfaceOverrides['Svenska'] && window.messagesInterfaceOverrides['Svenska'].only) || 'endast';
    el.textContent = "Ej tillgänglig på detta språk (" + seulement + ": " + allowed.join(", ") + ")";
    try{ jouerBipErreur && jouerBipErreur(); }catch(_){}
    return; // NE PAS passer à la page
} 
        if (disabledForms.includes(selectedQ)){
          const el=document.getElementById("menuError"); if(el) el.textContent = messagesInterface[currentLang].alertOption;
          try{ jouerBipErreur(); }catch(_){}
          alert(messagesInterface[currentLang].alertOption);
          return;
        }
        const label = qSel ? qSel.options[qSel.selectedIndex].text.replace(" (indisponible)","") : "DSM-5";
        const headerWord = (window.homeHeaderDefaultByLang &&        window.homeHeaderDefaultByLang[currentLang]) || 'Questionnaire';
       APP.nom = `${headerWord} ${label}`;   
        updateHeaderBar();
  // Force Swedish label if active language is Svenska
  try {
    var sbf = document.getElementById('sendToCodicentBtn');
    if (sbf && currentLang === 'Svenska') {
      sbf.textContent = "Skicka för analys";
    }
  } catch(_){}
        const intro = (introByForm[currentLang] && introByForm[currentLang][selectedQ]) ? introByForm[currentLang][selectedQ] : messagesInterface[currentLang].intro;
        const introText = document.getElementById("introText"); if (introText) introText.textContent = intro; introText.style.whiteSpace="pre-line"; introText.style.lineHeight="1.9";
        document.getElementById("menuScreen").style.display="none";
        document.getElementById("introScreen").style.display="block";
        setTimeout(()=>document.getElementById("codeInput").focus(),100);
      };
    }
    // DÉMARRER
    const startBtn = document.getElementById("startBtn");
    if (startBtn){
      startBtn.onclick = startQuestionnaire;
      document.getElementById("codeInput").addEventListener("keypress",e=>{ if(e.key==="Enter"){ e.preventDefault(); startQuestionnaire(); } });
    }
  });
  </script>
<!-- ======================================================
       AJOUTS FINAUX – TTS toggle + Micro sticky/auto-restart + Android/HTTPS
       ====================================================== -->
<script>
  (function(){
    // Variables globales (sécurisées si déjà définies)
    if (typeof window.recognition === "undefined") window.recognition = null;
    if (typeof window.listening   === "undefined") window.listening   = false;
    if (typeof window.currentLang === "undefined") window.currentLang = "Svenska";
    if (typeof window.ttsEnabled  === "undefined") window.ttsEnabled  = true;
    // Helper libellés (évite les crash si messagesInterface absent)
    function M(key, fallback){
      try { return (messagesInterface && messagesInterface[currentLang] && messagesInterface[currentLang][key]) || fallback; }
      catch(_){ return fallback; }
    }
    document.addEventListener("DOMContentLoaded", function(){
      var ttsBtn = document.getElementById("ttsToggleBtn");
      if (!ttsBtn) return;
      function updateTTSBtn(){ ttsBtn.textContent = window.ttsEnabled ? M('ttsOn','Vocal') : M('ttsOff','Silence'); }
      updateTTSBtn();
      ttsBtn.addEventListener("click", function(){
        window.ttsEnabled = !window.ttsEnabled;
        try { speechSynthesis.cancel(); } catch(_){}
        updateTTSBtn();
      });
    });
    // === Micro sticky / auto-restart ===
    var micSticky = false;
    var manuallyStopping = false;
    var restartTimer = null;
    // Lang reco
    if (typeof window.setRecognitionLang !== "function"){
      window.setRecognitionLang = function(){
        if(!recognition) return;
        recognition.lang = (currentLang==="English") ? "en-US"
                        : (currentLang==="Svenska") ? "sv-SE"
                        : "fr-FR";
      };
    }
    // Init/override reco (handlers robustes)
    window.initRecognition = function(){
      window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      var ms = document.getElementById("microStatus");
      if(!window.SpeechRecognition){
        if(ms) ms.textContent = (currentLang==="English") ? "🎤 Not supported on this device" : "🎤 Non supporté sur cet appareil";
        return;
      }
      var isFile = location.protocol === "file:";
      if(!window.isSecureContext && location.hostname!=="localhost" && !isFile){
        if(ms) ms.textContent = (currentLang==="English") ? "🎤 HTTPS required" : "🎤 HTTPS requis";
        return;
      }
      recognition = new window.SpeechRecognition();
      setRecognitionLang();
      recognition.continuous = true;
      recognition.interimResults = false;
      recognition.onstart = function(){
        listening = true;
        var ms = document.getElementById("microStatus");
        if (ms){ ms.textContent = M('microOn','Micro ouvert'); ms.style.color = "green"; }
        var btn = document.getElementById("voiceBtn");
        if (btn) btn.textContent = M('microOn','Micro ouvert');
      };
      recognition.onend = function(){
        listening = false;
        var ms = document.getElementById("microStatus");
        if (ms){ ms.textContent = M('microOff','Micro fermé'); ms.style.color = "red"; }
        var btn = document.getElementById("voiceBtn");
        if (btn) btn.textContent = M('microOff','Micro fermé');
        if (micSticky && !manuallyStopping && !document.hidden){
          clearTimeout(restartTimer);
          restartTimer = setTimeout(function(){
            try{ recognition.start(); listening = true; if(btn) btn.textContent = M('microOn','Micro ouvert'); }catch(_){}
          }, 300);
        }
        manuallyStopping = false;
      };
      recognition.onerror = function(e){
        listening = false;
        var err = e && e.error;
        if (err !== "aborted"){
          var ms = document.getElementById("microStatus");
          if (ms){
            var msg = "🎤 Erreur";
            if (err==="not-allowed"||err==="service-not-allowed") msg = (currentLang==="English")?"🎤 Permission denied (allow mic)":"🎤 Behörighet nekad (activez le micro)";
            else if (err==="audio-capture") msg = (currentLang==="English")?"🎤 Microphone not found":"🎤 Micro non détecté";
            else if (err==="no-speech")     msg = (currentLang==="English")?"🎤 No speech detected":"🎤 Pas de voix détectée";
            ms.textContent = msg;
          }
        }
        if (micSticky && !manuallyStopping && err!=="not-allowed" && err!=="service-not-allowed" && !document.hidden){
          clearTimeout(restartTimer);
          restartTimer = setTimeout(function(){
            try{ recognition.start(); listening = true; var btn=document.getElementById("voiceBtn"); if(btn) btn.textContent = M('microOn','Micro ouvert'); }catch(_){}
          }, 500);
        }
        manuallyStopping = false;
      };
      // onresult : on garde le tien si déjà défini ; sinon, on met une version neutre
      if (typeof recognition.onresult !== "function"){
        recognition.onresult = function(e){
          try{
            var r = e.results[e.results.length-1][0].transcript;
            var txt = (r||"").toLowerCase().trim();
            var a = document.getElementById("answerInput");
            if (a) a.value = txt;
          }catch(_){}
        };
      }
    };
    // Helpers démarrage/arrêt (gèrent sticky + UI + erreurs visibles)
    window.startMic = function(){
      if(!recognition) initRecognition();
      if(!recognition) return;
      try{ speechSynthesis.cancel(); }catch(_){}
      clearTimeout(restartTimer);
      setRecognitionLang();
      micSticky = true;
      var btn = document.getElementById("voiceBtn");
      var ms  = document.getElementById("microStatus");
      if (btn) btn.textContent = M('microOn','Micro ouvert');
      if (ms){ ms.textContent = M('microOn','Micro ouvert'); ms.style.color="green"; }
      try{
        recognition.start();
        listening = true;
      }catch(err){
        listening = false;
        micSticky = false;
        if (btn) btn.textContent = M('microOff','Micro fermé');
        if (ms)  ms.textContent  = "🎤 Erreur start: " + ((err && (err.name||err.message)) || "inconnue");
      }
    };
    window.stopMic = function(opts){
      opts = opts || {};
      var manual = (typeof opts.manual==="boolean") ? opts.manual : true;
      if(!recognition) return;
      manuallyStopping = manual;
      if (manual) micSticky = false;
      clearTimeout(restartTimer);
      try{ recognition.abort(); }catch(_){ try{ recognition.stop(); }catch(_){ } }
      listening = false;
      var btn = document.getElementById("voiceBtn");
      var ms  = document.getElementById("microStatus");
      if (btn) btn.textContent = M('microOff','Micro fermé');
      if (ms){ ms.textContent = M('microOff','Micro fermé'); ms.style.color="red"; }
    };
    // Bouton MICRO (remplace les handlers existants si besoin)
    document.addEventListener("DOMContentLoaded", function(){
      var btn = document.getElementById("voiceBtn");
      var ms  = document.getElementById("microStatus");
      if (!btn) return;
      btn.onclick = function(){
        var isAndroid = /Android/i.test(navigator.userAgent);
        var isSecure  = window.isSecureContext || location.protocol === "https:" || location.hostname === "localhost";
        if (listening || micSticky){
          stopMic({manual:true});
          return;
        }
        if (isAndroid && !isSecure){
          if (ms) ms.textContent = "🎤 Android exige HTTPS pour le micro";
          return;
        }
        // pré-permission uniquement Android
        if (isAndroid && navigator.mediaDevices && navigator.mediaDevices.getUserMedia){
          navigator.mediaDevices.getUserMedia({ audio:true })
            .then(function(s){ s.getTracks().forEach(function(t){t.stop();}); startMic(); })
            .catch(function(){ if (ms) ms.textContent = M('permDenied','🎤 Behörighet nekad (activez le micro)'); });
        } else {
          startMic();
        }
      };
    });
    // Visibilité onglet : stop temporaire / relance
    document.addEventListener("visibilitychange", function(){
      if (document.hidden && listening){
        stopMic({manual:false});
      } else if (!document.hidden && micSticky && !listening){
        startMic();
      }
    });
  })();
  </script>
<!-- === BEGIN: Unavailable label fix (handles (undefined)/language) === -->
<script>
(function(){
  function t(key, fallback){
    try { return (window.messagesInterface && window.messagesInterface[window.currentLang] && window.messagesInterface[window.currentLang][key]) ?? fallback ?? key; }
    catch(_){ return fallback ?? key; }
  }
  function normalizeLang(v){
    const s = String(v||'').toLowerCase();
    if (s.includes('english') || s === 'en') return 'English';
    if (s.includes('svensk') || s.includes('svenska') || s === 'sv') return 'Svenska';
    return 'Français';
  }
  function fixUnavailable(){
    const qsel = document.getElementById('questionnaireSelect');
    if (!qsel) return;
    const word = t('unavailable',
      (window.currentLang==='Svenska') ? 'otillgänglig' :
      (window.currentLang==='English') ? 'unavailable'  :
      'indisponible'
    );
    Array.prototype.slice.call(qsel.options).forEach(o=>{
      if (!o || typeof o.text !== 'string') return;
      // replace any (undefined|indisponible|unavailable|otillgänglig) at end
      o.text = o.text.replace(/\s*\((?:undefined|indisponible|unavailable|otillgänglig)\)\s*$/i, ` (${word})`);
    });
  }
  // Hook language changes if present
  document.addEventListener('DOMContentLoaded', function(){
    const langSel = document.getElementById('langSelect');
    if (langSel){
      langSel.addEventListener('change', function(){
        window.currentLang = normalizeLang(langSel.value);
        try{ fixUnavailable(); }catch(_){}
      });
    }
    try{ fixUnavailable(); }catch(_){}
  });
  // Patch updateQuestionnaireLabels to always fix after it runs
  (function(){
    const orig = window.updateQuestionnaireLabels;
    window.updateQuestionnaireLabels = function(){
      if (typeof orig === 'function'){ try{ orig.apply(this, arguments); }catch(_){ } }
      try{ fixUnavailable(); }catch(_){}
    };
  })();
})();

</script>
<!-- === END: Unavailable label fix === -->
<script>
(function(){
  function renderHomeIntroMinimal(){
    var box = document.getElementById('headerIntro');
    if (!box) return;
    var L = window.currentLang || 'Français';
    var lines = {
      'Français':[
        "Choisissez un questionnaire et une langue pour commencer.",
        "Vos réponses sont confidentielles. Prenez votre temps."
      ],
      'English':[
        "Pick a questionnaire and a language to get started.",
        "Your answers are confidential. Take your time."
      ],
      'Svenska':[
        "Välj formulär och språk för att börja.",
        "Dina svar är konfidentiella. Ta den tid du behöver."
      ]
    }[L] || ["Choisissez un questionnaire et une langue pour commencer."];
    box.innerHTML = lines.join('<br>');
    box.style.display = 'block';
  }
  document.addEventListener('DOMContentLoaded', function(){
    try{ renderHomeIntroMinimal(); }catch(e){}
  });
})();

</script>
<!-- HEADER d'accueil : lit la CONFIG + i18n + contrôle langue dispo -->
<!-- ========== CHARGEUR & NOTABLES ========== -->
<script>
    function getQuestionsFor(formId, lang){
      var bank = window.QUESTIONNAIRE_BANK || {};
      var form = bank[formId] || {};
      if (form[lang] && form[lang].length) return form[lang].slice();
      if (form["Français"] && form["Français"].length) return form["Français"].slice();
      var langs = Object.keys(form);
      for (var i=0;i<langs.length;i++){
        var L = langs[i];
        if (Array.isArray(form[L]) && form[L].length) return form[L].slice();
      }
      return [];
    }
    // Liste d’index notables par formulaire (adaptez à vos tableaux)
    const NOTABLES_BY_FORM = {
      DSM:         [6,7,8,9,10,11],
      SOMMEIL:     [3,4,5,6],
      NEUROLOGIE:  [2,3,7],
      PSYCHIATRIE: [1,5,6],
      MEDEG:       [4,8]
    };
    function applyNotables(formId, questions){
      var list = (NOTABLES_BY_FORM && NOTABLES_BY_FORM[formId]) || [];
      for (var i=0;i<list.length;i++){
        var idx = list[i];
        if (questions[idx]) questions[idx].type = "scale";
      }
    }
  </script>
<!-- ========== /CHARGEUR & NOTABLES ========== -->
<script id="homeHeader_i18n">
(function(){
  function setHomeHeaderTitle(){
    var title = document.getElementById('mainTitle');
    if (!title) return;
    var L = window.currentLang || 'Français';
    var map = (window.homeHeaderDefaultByLang && typeof window.homeHeaderDefaultByLang === 'object')
      ? window.homeHeaderDefaultByLang
      : { 'Français':'Questionnaire', 'English':'Questionnaire', 'Svenska':'Frågeformulär' };
    title.textContent = map[L] || map['Français'];
  }
  function renderHomeIntro(){
    var box = document.getElementById('headerIntro');
    if (!box) return;
    var L = window.currentLang || 'Français';
    var map = (window.homeHeaderIntroLinesByLang && typeof window.homeHeaderIntroLinesByLang === 'object')
      ? window.homeHeaderIntroLinesByLang
      : {
          'Français':[
            'Choisissez un questionnaire et une langue pour commencer.',
            'Vos réponses sont confidentielles. Prenez votre temps.'
          ],
          'English':[
            'Pick a questionnaire and a language to get started.',
            'Your answers are confidential. Take your time.'
          ],
          'Svenska':[
            'Välj formulär och språk för att börja.',
            'Dina svar är konfidentiella. Ta den tid du behöver.'
          ]
        };
    var lines = map[L] || map['Français'];
    box.innerHTML = (lines||[]).join('<br>');
    box.style.display = 'block';
  }
  function notAvailMessage(selLang, onlyLangs){
    var mi = (window.messagesInterface && messagesInterface[selLang]) || {};
    var prefix = mi.notAvailableLang
      || (selLang==='English' ? 'Not available in this language'
          : selLang==='Svenska' ? 'Inte tillgängligt på detta språk'
          : 'Non disponible dans cette langue');
    var onlyWord = mi.only
      || (selLang==='English' ? 'only' : selLang==='Svenska' ? 'endast' : 'seulement');
    var abbr = { 'Français':'Fr', 'Svenska':'Su', 'English':'Ang' };
    var ab = (onlyLangs||[]).map(function(L){ return abbr[L] || L; }).join('/');
    return prefix + ' — ' + onlyWord + ': ' + ab;
  }
  document.addEventListener('DOMContentLoaded', function(){
    var lSel = document.getElementById('langSelect');
    var qSel = document.getElementById('questionnaireSelect');
    var btn  = document.getElementById('nextLangBtn');
    var err  = document.getElementById('menuError');
    if (lSel && lSel.value) window.currentLang = lSel.value;
    setHomeHeaderTitle();
    renderHomeIntro();
    if (lSel){
      lSel.addEventListener('change', function(){
        window.currentLang = lSel.value || 'Français';
        setHomeHeaderTitle();
        renderHomeIntro();
      });
    }
    // disponibilité par questionnaire (utilise la CONFIG si fournie)
    window.availableLangsByForm = window.availableLangsByForm || { DSM:['Français'] };
    if (btn && qSel){
      var oldHandler = btn.onclick;
      btn.onclick = function(){
        var formId = (qSel.value||'').trim();
        var lang   = window.currentLang || (lSel && lSel.value) || 'Français';
        var okList = (window.availableLangsByForm && window.availableLangsByForm[formId]) || ['Français'];
        if (okList.indexOf(lang) === -1){
          if (err){ err.textContent = notAvailMessage(lang, okList); }
          try{ if (window.jouerBipErreur) jouerBipErreur(); }catch(_){}
          return;
        }
        try{ var hi=document.getElementById('headerIntro'); if(hi) hi.style.display='none'; }catch(_){}
        if (typeof oldHandler === 'function') return oldHandler.call(this);
      };
    }
  });
})();

</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  // APP.version override (optionnel)
  if (window.APP_VERSION_OVERRIDE && typeof window.APP_VERSION_OVERRIDE === 'string' && window.APP_VERSION_OVERRIDE.trim() !== ''){
    try{
      if (window.APP){ APP.version = window.APP_VERSION_OVERRIDE; }
      if (typeof updateHeaderBar === 'function'){ updateHeaderBar();
  // Force Swedish label if active language is Svenska
  try {
    var sbf = document.getElementById('sendToCodicentBtn');
    if (sbf && currentLang === 'Svenska') {
      sbf.textContent = "Skicka för analys";
    }
  } catch(_){}
 }
    }catch(_){}
  }
  // introByForm overrides (merge propriété à propriété)
  try{
    if (window.introByFormOverrides && window.introByForm){
      Object.keys(window.introByFormOverrides).forEach(function(lang){
        if (!introByForm[lang]) introByForm[lang] = {};
        var src = window.introByFormOverrides[lang] || {};
        Object.keys(src).forEach(function(formId){
          introByForm[lang][formId] = src[formId];
        });
      });
    }
  }catch(_){}
  // messagesInterface overrides (merge)
  try{
    if (window.messagesInterfaceOverrides && window.messagesInterface){
      Object.keys(window.messagesInterfaceOverrides).forEach(function(lang){
        var src = window.messagesInterfaceOverrides[lang] || {};
        if (!messagesInterface[lang]) messagesInterface[lang] = {};
        Object.keys(src).forEach(function(k){
          messagesInterface[lang][k] = src[k];
        });
      });
    }
  }catch(_){}
});

</script>
<!-- HARD-STOP language guard: blocks immediately if chosen language is not Svenska -->
<script>
document.addEventListener('DOMContentLoaded', function(){
  try{
    var btn = document.getElementById('nextLangBtn');
    if (!btn) return;
    // Capture-phase so we run BEFORE any other click handlers
    btn.addEventListener('click', function(ev){
      try{
        var ls = document.getElementById('langSelect');
        var chosen = (ls && ls.value) ? ls.value : 'Svenska';
        if (chosen !== 'Svenska'){
          var el = document.getElementById('menuError');
          var word = (chosen==='English' ? 'Language' : chosen==='Svenska' ? 'Språk' : 'Langue');
          var na   = (chosen==='English' ? 'Unavailable' : chosen==='Svenska' ? 'Ej tillgänglig' : 'Non disponible');
          if (el) el.textContent = word + ' : ' + na + ' (endast: Svenska)';
          try { if (typeof jouerBipErreur==='function') jouerBipErreur(); } catch(_){}
          ev.stopImmediatePropagation(); // stop other handlers
          ev.preventDefault();
          return false;
        }
      }catch(_){}
      return true;
    }, true); // <-- CAPTURE
  }catch(_){}
});

</script>
<script>
(function(){
  function getLang(){
    try { return window.currentLang || (document.documentElement.getAttribute('lang')==='sv'?'Svenska':'Français'); }
    catch(_){ return 'Français'; }
  }
  function invalidMsgFor(lang){
    if (lang==='English') return 'Rewrite your answer';
    if (lang==='Svenska') return 'Skriv om ditt svar';
    return 'Réécrivez votre réponse';
  }
  // Essaie de localiser le champ "Ange ditt svar"
  function findScoreInput(){
    // 1) ID habituel
    var el = document.getElementById('scoreInput');
    if (el) return el;
    // 2) Chercher le label contenant "Ange ditt svar"
    var labels = document.querySelectorAll('label, .label, span, p, div');
    for (var i=0;i<labels.length;i++){
      var t = (labels[i].innerText||labels[i].textContent||'').trim().toLowerCase();
      if (t.includes('ange ditt svar')){
        // champ immédiatement après ou dans le même conteneur
        var next = labels[i].nextElementSibling;
        if (next && next.tagName==='INPUT') return next;
        var input = labels[i].parentElement && labels[i].parentElement.querySelector('input');
        if (input) return input;
      }
    }
    // 3) fallback: un input number borné 1–5 visible
    var cand = document.querySelector('input[type="number"][min="1"][max="5"]');
    if (cand) return cand;
    // 4) dernier recours: premier input visible
    return document.querySelector('input');
  }
  function ensureErrorBelow(input){
    var el = document.getElementById('scoreError');
    if (!el){
      el = document.createElement('div');
      el.id = 'scoreError';
      el.style.cssText = 'color:blue;font-weight:bold;margin-top:4px;display:block;';
      input.insertAdjacentElement('afterend', el);
    }
    return el;
  }
  function showInvalid(){
    var input = findScoreInput(); if(!input) return;
    var msg = invalidMsgFor(getLang());
    var el = ensureErrorBelow(input);
    el.textContent = msg;
    try { if (typeof jouerBipErreur==='function') jouerBipErreur(); } catch(_){}
  }
  function clearInvalid(){
  try{ var si=document.getElementById('scoreInput')||null; if(!si){var q=document.querySelector('input[type="number"][min]'); if(q) si=q;} if (si) si.__showingInvalid=false; }catch(_){}
    var el = document.getElementById('scoreError');
    if(el) el.textContent = '';
  }
  function validateVal(v){
    var n = parseInt(v,10);
    if (isNaN(n) || n<1 || n>5){ showInvalid(); return false; }
    clearInvalid(); return true;
  }
  function attach(){
    var si = findScoreInput();
    if(!si || si.__hasValidation) return;
    si.__hasValidation = true;
    si.addEventListener('blur',   function(){ validateVal(this); });
    si.addEventListener('change', function(){ validateVal(this); });
    si.addEventListener('keydown',function(e){ if(e.key==='Enter'){ validateVal(this); }});
    // Bloquer la navigation si invalide
    var btn = document.getElementById('nextLangBtn') || document.getElementById('nextBtn') || document.querySelector('button[type="submit"]');
    if (btn && !btn.__scoreGuard){
      btn.__scoreGuard = true;
      btn.addEventListener('click', function(ev){
        var s = findScoreInput();
        if (s && s.offsetParent!==null && !validateVal(s)){
          ev.preventDefault(); ev.stopImmediatePropagation();
          return false;
        }
        return true;
      }, true); // capture
    }
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', attach);
  } else {
    attach();
  }
  // Si le champ apparaît plus tard (changement de page), on ré-attache
  var obs = new MutationObserver(attach);
  try { obs.observe(document.documentElement, {childList:true, subtree:true}); } catch(_){}
})();

</script>

<script>
// MODIF ajustement des langues — fin de réponse robuste (STOP/SLUT/SLUTA) sans toucher à tes fonctions
(function(){
  // Normalisation (minuscules, accents retirés, ponctuation enlevée)
  function norm(s){
    if (typeof s !== "string") return "";
    s = s.toLowerCase().trim();
    if (s.normalize) s = s.normalize("NFKD").replace(/[\u0300-\u036f]/g,"");
    return s.replace(/[.,!?;:()\[\]{}"«»…]/g," ").replace(/\s+/g," ").trim();
  }
  // On accepte ces mots-clés (pour fiabiliser la reco Edge: "slut." / "sluta.")
  function hasEndWord(s){
    const n = norm(s);
    // si tu veux strictement par langue, remets le test sur window.currentLang ici
    return /\b(stop|slut|sluta)\b/i.test(n);
  }
  function stripEndWord(s){
    let n = norm(s);
    n = n.replace(/\b(stop|slut|sluta)\b/gi,"").replace(/\s+/g," ").trim();
    return n;
  }
  // Trouver le champ de réponse "actif" (input texte ou textarea visible)
  function getActiveAnswerEl(){
    const cand = Array.from(document.querySelectorAll('textarea, input[type="text"], input:not([type])'));
    const vis = cand.filter(el => el && el.offsetParent !== null && !el.disabled && !el.readOnly);
    if (document.activeElement && vis.includes(document.activeElement)) return document.activeElement;
    // fallback: le plus large (souvent le champ principal)
    return vis.sort((a,b)=> (b.clientWidth*b.clientHeight) - (a.clientWidth*a.clientHeight))[0] || null;
  }
  // Nettoie + valide (après que ton code a écrit dans le champ)
  function cleanAndValidateNow(el){
    if (!el) return;
    const raw = el.value;
    if (!raw) return;
    if (!hasEndWord(raw)) return;
    const cleaned = stripEndWord(raw);
    setTimeout(function(){
      const e = getActiveAnswerEl() || el;
      if (e) e.value = cleaned;
      if (typeof validateAnswer === "function") validateAnswer();
    }, 0);
  }
  // Écoute tous les changements d’entrée (clavier, reco, etc.)
  document.addEventListener('input', function(ev){
    const t = ev && ev.target;
    if (!t) return;
    if (t.matches('textarea, input[type="text"], input:not([type])')){
      // laisse d'abord les autres handlers finir, puis on agit
      setTimeout(()=> cleanAndValidateNow(t), 0);
    }
  }, true);
  // Sécurité : si ton code met à jour sans déclencher 'input', on scrute les variations
  let lastVal = "";
  setInterval(function(){
    const el = getActiveAnswerEl();
    if (!el) return;
    const v = el.value;
    if (v !== lastVal){
      lastVal = v;
      setTimeout(()=> cleanAndValidateNow(el), 0);
    }
  }, 200);
})();

</script>
<script>
// MODIF — focus automatique après clic sur TYST/RÖST et MICRO (additif, sans override)
(function(){
  // Définir focusAnswer uniquement si elle n'existe pas déjà
  if (typeof window.focusAnswer !== "function"){
    window.focusAnswer = function(){
      try{
        var a = document.getElementById("answerInput");
        if (!a) return;
        a.focus();
        // place le curseur à la fin
        var v = a.value || "";
        try{ a.setSelectionRange(v.length, v.length); }catch(_){}
      }catch(_){}
    };
  }
  function attachFocusAfterClick(el){
    if (!el) return;
    // On n'empêche rien : on se contente d'ajouter un listener APRES ton handler
    el.addEventListener("click", function(){
      // Laisse d'abord le bouton faire son toggle, puis remet le focus
      setTimeout(window.focusAnswer, 0);
    }, false);
  }
  // Boutons connus par id
  attachFocusAfterClick(document.getElementById("ttsToggleBtn")); // TYST/RÖST
  attachFocusAfterClick(document.getElementById("voiceBtn"));     // MICRO
  // Filet de sécurité : si les IDs changent, on tente sur les boutons dont le texte contient TYST/RÖST/VOICE/MICRO
  var candidates = Array.from(document.querySelectorAll('button, [role="button"]'))
    .filter(function(b){
      var t = (b.textContent || "").toLowerCase();
      return /tyst|röst|rost|voice|micro|mikro/i.test(t);
    });
  candidates.forEach(attachFocusAfterClick);
})();

</script>
<script>
/* ===== TTS — bloc unique (PC / Samsung) ===== */
/* IMPORTANT: garde UNE SEULE fois cette déclaration dans tout le fichier */
var synth = window.speechSynthesis || null;
var __voices = [];
var TTS_STORE_KEY = "ttsVoiceNameByLangCode";
var ttsVoiceNameByLang = {};
// 1) Map currentLang -> BCP-47
function getCurrentLangCode(){
  var txt = (window.currentLang || "").toLowerCase();
  if (txt.indexOf("sv")===0) return "sv-SE";
  if (txt.indexOf("en")===0) return "en-US";
  if (txt.indexOf("fr")===0) return "fr-FR";
  return "fr-FR";
}
// 2) Store
(function(){
  try{ ttsVoiceNameByLang = JSON.parse(localStorage.getItem(TTS_STORE_KEY) || "{}"); }
  catch(_){ ttsVoiceNameByLang = {}; }
})();
function tts_saveStore(){ try{ localStorage.setItem(TTS_STORE_KEY, JSON.stringify(ttsVoiceNameByLang)); }catch(_){} }
// 3) Candidates
function tts_candidatesForLang(langCode){
  var want = langCode.indexOf("sv")===0 ? ["sv-SE","sv"]
           : langCode.indexOf("en")===0 ? ["en-US","en-GB","en"]
           :                               ["fr-FR","fr-CA","fr"];
  var low = function(s){ return (s||"").toLowerCase(); };
  var vendorsFirst = function(v){ return /google|microsoft|samsung|apple/i.test(v.name); };
  var exact = (__voices||[]).filter(function(v){ return want.indexOf(v.lang)>=0 || want.indexOf((v.lang||"").substr(0,5))>=0; });
  var langOnly = (__voices||[]).filter(function(v){
    return exact.indexOf(v)===-1 && want.some(function(w){ return low(v.lang).indexOf(low(w.substring(0,2)))===0; });
  });
  return exact.concat(langOnly).sort(function(a,b){ return (vendorsFirst(b)-vendorsFirst(a)); });
}
// 4) UI strings
function tts_uiStrings(){
  var code = getCurrentLangCode();
  if (code.indexOf("sv")===0){
    return {
      label:"Röst (enligt enheten):",
      test:"Rösttest",
      hint:"Valet sparas per språk. Använd ”Rösttest”.",
      noVoice:function(lc){ return "Ingen lokal röst tillgänglig för " + lc + ". Installera rösten i Android/Windows."; }
    };
  }
  if (code.indexOf("en")===0){
    return {
      label:"Voice (device):",
      test:"Test voice",
      hint:"Choice saved per language. Use “Test voice”.",
      noVoice:function(lc){ return "No local voice available for " + lc + ". Install the voice in Android/Windows."; }
    };
  }
  return {
    label:"Voix (selon l'appareil) :",
    test:"Test voix",
    hint:"Choix mémorisé par langue. Utilise « Test voix ».",
    noVoice:function(lc){ return "Aucune voix locale disponible pour " + lc + ". Installe la voix dans Android/Windows."; }
  };
}
function tts_applyUILabels(){
  var s = tts_uiStrings();
  // Trouve le label de manière robuste (plusieurs fallback)
  var lab = document.getElementById("voiceLabel");
  if (!lab) {
    lab = document.querySelector('label[for="voiceSelect"]');
    if (!lab) {
      var sel = document.getElementById("voiceSelect");
      // remonte jusqu'au conteneur #voiceRow puis cherche le 1er label
      var n = sel;
      while (n && n.id !== "voiceRow") n = n.parentNode;
      if (n) lab = n.querySelector("label");
    }
  }
  var btn  = document.getElementById("testVoiceBtn");
  var hint = document.getElementById("voiceHint");
  if (lab)  lab.textContent  = s.label;   // ex: "Röst (enligt enheten):"
  if (btn)  btn.textContent  = s.test;    // ex: "Rösttest"
  if (hint) hint.textContent = s.hint;    // ex: "Valet sparas per språk…"
}
// 5) Populate select
function tts_populateVoiceSelect(){
  var sel  = document.getElementById("voiceSelect");
  var hint = document.getElementById("voiceHint");
  if (!sel) return;
  sel.innerHTML = "";
  var langCode = getCurrentLangCode();
  var list = tts_candidatesForLang(langCode);
  var key = langCode.substring(0,2).toUpperCase(); // SV/FR/EN
  var stored = ttsVoiceNameByLang[key];
  var ui = tts_uiStrings();
  if (!list.length){
    var o = document.createElement("option");
    o.value = ""; o.textContent = ui.noVoice(langCode);
    sel.appendChild(o);
    if (hint) hint.textContent = ui.noVoice(langCode);
    tts_applyUILabels();
    return;
  }
  list.forEach(function(v){
    var o = document.createElement("option");
    o.value = v.name; o.textContent = v.name + " (" + v.lang + ")";
    sel.appendChild(o);
  });
  if (stored && list.find(function(v){ return v.name===stored; })) {
    sel.value = stored;
  } else {
    sel.selectedIndex = 0;
  }
  tts_applyUILabels();
}
// 6) Selected voice
function tts_getSelectedVoice(){
  var sel = document.getElementById("voiceSelect");
  var name = sel && sel.value;
  return name ? (__voices||[]).find(function(v){ return v.name===name; }) || null : null;
}
// 7) Load voices
function tts_loadVoices(){
  try{ __voices = synth ? (synth.getVoices() || []) : []; }catch(_){ __voices = []; }
  if (typeof tts_populateVoiceSelect==='function'){ tts_populateVoiceSelect(); }
}
if (typeof speechSynthesis !== "undefined"){
  speechSynthesis.onvoiceschanged = tts_loadVoices;
  setTimeout(tts_loadVoices, 0);
  setTimeout(tts_loadVoices, 600);
}
// 8) Wire UI + sync with existing language menu (#langSelect)
document.addEventListener("DOMContentLoaded", function(){
  var langSel = document.getElementById("langSelect");
  if (langSel){
    window.currentLang = langSel.value || (langSel.options[langSel.selectedIndex] && langSel.options[langSel.selectedIndex].text) || window.currentLang || "Français";
    onUILanguageChanged();
    langSel.addEventListener("change", function(){
      window.currentLang = langSel.value || (langSel.options[langSel.selectedIndex] && langSel.options[langSel.selectedIndex].text) || "Français";
      onUILanguageChanged();
    });
  } else {
    window.currentLang = window.currentLang || "Français";
  }
  var sel = document.getElementById("voiceSelect");
  if (sel){
    sel.addEventListener("change", function(){
      var key = getCurrentLangCode().substring(0,2).toUpperCase();
      ttsVoiceNameByLang[key] = sel.value || "";
      tts_saveStore();
    });
  }
  var testBtn = document.getElementById("testVoiceBtn");
  if (testBtn){
    testBtn.addEventListener("click", function(){
      var code = getCurrentLangCode();
      var sample = code.indexOf("sv")===0 ? "Det här är ett rösttest."
                 : code.indexOf("en")===0 ? "This is a voice test."
                 : "Ceci est un test de voix.";
      tts_testSpeak(sample);
    });
  }
  tts_loadVoices();
  tts_applyUILabels();
});
// 9) Test voice
function tts_testSpeak(text){
  if (!synth || !text) return;
  try{
    var u = new SpeechSynthesisUtterance(text);
    u.lang = getCurrentLangCode();
    var v = tts_getSelectedVoice(); if (v) u.voice = v;
    u.rate = 1.0; u.pitch = 1.0;
    synth.cancel(); synth.speak(u);
  }catch(_){}
}
// 10) Call when UI language changed (and at end of updateInterfaceLang)
function onUILanguageChanged(){
  try { 
    if (typeof tts_populateVoiceSelect==='function'){ tts_populateVoiceSelect(); }
    tts_applyUILabels();
  } catch(_) {}
}
// 11) Unified speak
function lireTexte(txt){
  if (!window.ttsEnabled || !txt || !synth) return;
  if (!__voices || __voices.length === 0){ setTimeout(function(){ lireTexte(txt); }, 350); return; }
  try{
    var plain = String(txt).replace(/<[^>]+>/g,"");
    var u = new SpeechSynthesisUtterance(plain);
    u.lang = getCurrentLangCode();
    var v = tts_getSelectedVoice(); if (v) u.voice = v;
    u.rate = 1.0; u.pitch = 1.0;
    synth.cancel(); synth.speak(u);
  }catch(_){}
}

</script>
<script>
(function(){
  if (!('speechSynthesis' in window)) return;
  if (window.__speakGuardLight) return;
  window.__speakGuardLight = true;
  var _speak = speechSynthesis.speak.bind(speechSynthesis);
  speechSynthesis.speak = function(u){
    try { if (typeof window.ttsEnabled !== 'undefined' && !window.ttsEnabled) return; } catch(_){}
    _speak(u);
  };
})();

</script>
<script>
// === Auto-clear 'not available' error when allowed language is reselected (FR parity) ===
document.addEventListener('DOMContentLoaded', function(){
  function clearNotAvailIfAllowed(){
    try{
      var qSel = document.getElementById('questionnaireSelect');
      var lSel = document.getElementById('langSelect');
      var err  = document.getElementById('menuError');
      if (!qSel || !lSel || !err) return;
      var formId = (qSel.value||'DSM');
      var lang   = (window.currentLang || lSel.value || 'Svenska');
      var okList = (window.availableLangsByForm && window.availableLangsByForm[formId]) || ['Svenska'];
      if (okList.indexOf(lang) !== -1){
        err.textContent = "";
      }
    }catch(_){}
  }
  var lSel = document.getElementById('langSelect');
  var qSel = document.getElementById('questionnaireSelect');
  if (lSel){ lSel.addEventListener('change', clearNotAvailIfAllowed); }
  if (qSel){ qSel.addEventListener('change', clearNotAvailIfAllowed); }
  // initial check
  clearNotAvailIfAllowed();
});

</script>
<!-- === PATCH: Corriger (2 nivåer) — rensa sedan föregående fråga (forceIndex + robust idx) === -->
<script>
(function(){
  let __corrigerStage = 0;     // 0 = rensa denna, 1 = gå till föregående
  let __lastCorrigerTs = 0;

  function getDisplayedIndex(){
    var idx = -1;
    try{
      var el = document.getElementById('questionNum');
      if (el){
        var m = el.textContent.match(/(\d+)\s*\/\s*(\d+)/);
        if (m) idx = parseInt(m[1], 10) - 1;
      }
    }catch(_){}
    if (!(idx >= 0) && typeof window.currentQuestion === 'number') idx = window.currentQuestion;
    return idx;
  }

  function wireCorriger(){
    const btn = document.getElementById('corrigerBtn');
    if (!btn) return;

    // Ersätt noden för att ta bort gamla lyssnare
    const clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);

    function handler(ev){
      if (ev){
        ev.preventDefault();
        ev.stopPropagation();
        if (ev.stopImmediatePropagation) ev.stopImmediatePropagation();
      }
      const now = Date.now();
      if (now - __lastCorrigerTs > 4000) __corrigerStage = 0;
      __lastCorrigerTs = now;

      // Alltid: stäng mikro och skala
      try { if (window.recognition && window.listening) { recognition.abort && recognition.abort(); recognition.stop && recognition.stop(); window.listening = false; } } catch(_){}
      try {
        const sc = document.getElementById('scoreContainer');
        if (sc) sc.style.display = 'none';
        const si = document.getElementById('scoreInput');
        if (si) si.value = '';
      } catch(_) {}

      if (__corrigerStage === 0) {
        // NIVÅ 1: rensa och stanna på samma fråga (textläge + fokus)
        const f = document.getElementById('answerInput');
        if (f) { f.disabled = false; f.style.display = 'block'; f.value = ''; setTimeout(function(){ if (f.focus) f.focus(); }, 60); }
        window.justCorrected = true;
        try {
          const m = (window.messagesInterface && window.messagesInterface[window.currentLang]) || {};
          const err = document.getElementById('mainErrorMsg');
          if (err) { err.textContent = m.alertRewrite || "Skriv om ditt svar"; setTimeout(function(){ err.textContent=""; }, 1800); }
        } catch(_){ }
        __corrigerStage = 1; // nästa klick => föregående
      } else {
        // NIVÅ 2: gå till föregående fråga (robust)
        __corrigerStage = 0;
        window.justCorrected = false;
        var idx = getDisplayedIndex();
        var target = (typeof idx === 'number' && idx > 0) ? (idx - 1) : 0;
        window.__forceIndex = target; // låt showQuestion() använda detta index
        setTimeout(function(){ if (window.showQuestion) window.showQuestion(); }, 50);
      }
    }

    clone.addEventListener('click', handler, false);

    // Capture-level interception på dokumentet (om nån annan handler reste kvar)
    document.addEventListener('click', function(ev){
      var t = ev.target;
      var btn2 = (t && t.id === 'corrigerBtn') ? t : (t && t.closest ? t.closest('#corrigerBtn') : null);
      if (btn2){
        handler(ev);
      }
    }, true);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', wireCorriger);
  } else {
    wireCorriger();
  }
})();

</script>
<!-- OPTION A PATCH: Q34/35/36/38/39/40 => Verbal 1 + MIXTE (Texte → Échelle) -->
<script>
(function(){
  'use strict';
  function runPatch(){
    try{
      var toIdx = function(n){ return (Number(n)-1)|0; };
      var targetsQ = [34,35,36,38,39,40];
      var targets = targetsQ.map(toIdx);

      function toSet(x){
        if (x instanceof Set) return new Set(Array.from(x));
        if (Array.isArray(x)) return new Set(x);
        return new Set();
      }

      // Ensure globals
      window.NOTABLES_SET = new Set([]);? window.notables : Array.from(window.NOTABLES_SET || []));
      window.MIXED_QUESTIONS = toSet(window.MIXED_QUESTIONS);
      window.VERBAL_SCALE_QUESTIONS = toSet(window.VERBAL_SCALE_QUESTIONS);

      // 1) Mark as Verbal 1
      targets.forEach(function(i){ window.VERBAL_SCALE_QUESTIONS.add(i); });

      // 2) MIXED: text first → remove "notables" + clear type="scale"
      targets.forEach(function(i){
        window.MIXED_QUESTIONS.add(i);
        window.NOTABLES_SET.delete(i);
        if (window.questions && window.questions[i]){ try{ delete window.questions[i].type; }catch(_){ } }
      });

      // 3) Resync 'notables' array if used
      window.notables = Array.from(window.NOTABLES_SET);

      // 4) Guarantee the verbal1 label on these targets
      (function(){
        var L = (window.SCALE_LABELS && window.SCALE_LABELS.sv) || {
          verbal1: ["inte alls","kanske","lite","ganska mycket","mycket"],
          helpPrefix: "Välj 1–5"
        };
        var orig = window.applyScaleLabels;
        window.applyScaleLabels = function(qIndex){
          try{
            if (targets.indexOf(qIndex) >= 0){
              var lbl = document.getElementById("scoreLabel");
              if (lbl){
                var labels = L.verbal1;
                lbl.textContent = (L.helpPrefix || "Välj 1–5") + ": " + labels.map(function(x,i){ return (i+1)+"="+x; }).join(", ");
              }
              var si = document.getElementById("scoreInput");
              if (si){ si.min="1"; si.max="5"; }
              return;
            }
          }catch(_){}
          if (typeof orig === "function") return orig(qIndex);
        };
      })();

      // 5) Safety: enforce text-first on these targets even if some other path opens score
      (function(){
        function textFirst(){
          var cq = ((Number(window.currentQuestion)||0)|0);
          if (targets.indexOf(cq) < 0) return;
          var sc = document.getElementById("scoreContainer"); if (sc){ sc.style.display="none"; sc.hidden=true; }
          var ta = document.getElementById("answerInput");   if (ta){ ta.disabled=false; ta.style.display="block"; if(!ta.value) ta.value=""; try{ ta.focus(); }catch(_){ } }
        }
        if (typeof window.showQuestion === "function"){
          var o = window.showQuestion;
          window.showQuestion = function(){
            var r = o.apply(this, arguments);
            var k=10; (function loop(){ textFirst(); if(--k>0) requestAnimationFrame(loop); })();
            return r;
          };
        }
        document.addEventListener("click", function(ev){
          var btn = ev.target && ev.target.closest && ev.target.closest("#validateScoreBtn, #validerBtn, #nextBtn, #prevBtn");
          if (!btn) return;
          setTimeout(textFirst, 0);
          setTimeout(textFirst, 120);
        }, true);
      })();
    }catch(e){ console.warn("Option A patch error", e); }
  }
  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", function(){ setTimeout(runPatch, 0); });
  } else {
    setTimeout(runPatch, 0);
  }
})();

</script>
<script>
// TTS FIX WRAPPER v1 — non-intrusive add-on (does not modify existing functions)
(function(){
  function byId(id){return document.getElementById(id);}
  function isScaleIndex(idx){
    try {
      if (!Number.isFinite(idx)) return false;
      if (window.questions && window.questions[idx] && window.questions[idx].type==="scale") return true;
      if (window.NOTABLES_SET && typeof window.NOTABLES_SET.has==="function") return window.NOTABLES_SET.has(idx);
    } catch(_) {}
    return false;
  }
  function fallbackScaleText(){
    try{
      var L = (window.SCALE_LABELS && window.SCALE_LABELS.sv) ? window.SCALE_LABELS.sv : null;
      return L ? (L.helpPrefix + " 1–5") : "Välj 1–5";
    }catch(_){ return "Välj 1–5"; }
  }
  function speakCurrent(){
    try{
      var idx = window.currentQuestion;
      if (!Number.isFinite(idx)) return;
      var q = (window.questions && window.questions[idx]) || {};
      var t = q.text || "";
      if (!t && isScaleIndex(idx)) t = fallbackScaleText();
      if (window.ttsEnabled && typeof window.lireTexte === "function") window.lireTexte(t);
    }catch(_){}
  }

  // --- Fix TTS toggle button even if inline onclick is broken/minified ---
  function updateTTSBtn(){
    var btn = byId("ttsToggleBtn");
    if (!btn) return;
    try{
      btn.textContent = (window.ttsEnabled ? "Tyst" : "Röst"); // Swedish
      btn.setAttribute("aria-pressed", !!window.ttsEnabled);
    }catch(_){}
  }
  function attachToggle(){
    var btn = byId("ttsToggleBtn");
    if (!btn) return;
    try{
      btn.onclick = null; btn.removeAttribute('onclick'); // neutralize inline handler if present/minified
      btn.addEventListener("click", function(ev){
        ev.preventDefault(); ev.stopPropagation();
        window.ttsEnabled = !window.ttsEnabled;
        try{ localStorage.setItem('tts_on', window.ttsEnabled ? '1' : '0'); }catch(_){}
        try{ window.speechSynthesis && window.speechSynthesis.cancel && window.speechSynthesis.cancel(); }catch(_){}
        updateTTSBtn();
      }, {passive:false});
      updateTTSBtn();
    }catch(_){}
  }

  // --- Speak whenever currentQuestion changes (covers SKIP and normal next) ---
  var lastIdx = -999;
  function poll(){
    try{
      var main = byId("main");
      if (main && main.style.display !== "none"){
        var idx = window.currentQuestion;
        if (idx !== lastIdx){
          lastIdx = idx;
          setTimeout(speakCurrent, 50);
        }
      }
    }catch(_){}
  }

  // Ensure global flag exists
  if (typeof window.ttsEnabled !== "boolean") window.ttsEnabled = false;

  document.addEventListener("DOMContentLoaded", function(){
    attachToggle();
    updateTTSBtn();
    setInterval(poll, 200);
  });
})();
</script>
<!-- === TTS FIX WRAPPER v2 (non-intrusif) === -->
<script>
(function(){
  // --- Persistence TTS (lis état mémorisé, sinon conserve valeur existante) ---
  try{
    var st = localStorage.getItem('tts_on');
    if (st === '1') { window.ttsEnabled = true; }
    else if (st === '0') { window.ttsEnabled = false; }
    else if (typeof window.ttsEnabled !== "boolean") { window.ttsEnabled = false; }
  } catch(_){ if (typeof window.ttsEnabled !== "boolean") window.ttsEnabled = false; }

  // --- Helper: détection "échelle" sans texte ---
  function isScaleIndex(idx){
    try{
      var q = (window.questions && window.questions[idx]) || {};
      if (q && q.type === "scale") return true;
      if (window.NOTABLES_SET && window.NOTABLES_SET.has(idx)) return true;
    }catch(_){}
    return false;
  }
  function fallbackScaleText(){
    try{
      var L = (typeof window.SCALE_LABELS !== "undefined" && window.SCALE_LABELS.sv) ? window.SCALE_LABELS.sv : null;
      return L ? (L.helpPrefix + " 1–5") : "Välj 1–5";
    }catch(_){}
    return "Välj 1–5";
  }
  function speakCurrent(){
    try{
      if (!window.ttsEnabled) return;
      var idx = window.currentQuestion;
      if (!Number.isFinite(idx)) return;
      var q = (window.questions && window.questions[idx]) || {};
      var t = q && q.text ? q.text : "";
      if (!t && isScaleIndex(idx)) t = fallbackScaleText();

      if (typeof window.lireTexte === "function"){
        window.lireTexte(t);
      } else {
        // Fallback direct via Web Speech
        try{
          if (!("speechSynthesis" in window)) return;
          window.speechSynthesis.cancel();
          var u = new SpeechSynthesisUtterance(t);
          // Choix d'une voix sv-SE si dispo
          var vs = window.speechSynthesis.getVoices();
          var sv = (vs||[]).find(function(v){ return /sv-SE/i.test(v.lang||""); });
          if (sv) u.voice = sv;
          window.speechSynthesis.speak(u);
        }catch(_){}
      }
    }catch(_){}
  }

  // --- Wrap showQuestion(): après l'appel d'origine, relancer la voix ---
  try{
    if (typeof window.showQuestion === "function" && !window.__showQuestionWrapped){
      window.__origShowQuestion = window.showQuestion;
      window.showQuestion = function(){
        try{ return window.__origShowQuestion.apply(this, arguments); }
        finally { speakCurrent(); }
      };
      window.__showQuestionWrapped = true;
    }
  }catch(_){}

  // --- Bouton RÖST/TYST : neutralise l'onclick inline et rattache notre toggle persistant ---
  function updateTTSBtn(){
    try{
      var b = document.getElementById("ttsToggleBtn");
      if (!b) return;
      var m = (window.messagesInterface && window.messagesInterface[window.currentLang]) || null;
      var labelOn  = m ? (m.ttsOn  || "Röst")  : "Röst";
      var labelOff = m ? (m.ttsOff || "Tyst") : "Tyst";
      b.textContent = window.ttsEnabled ? labelOn : labelOff;
      b.setAttribute("aria-pressed", window.ttsEnabled ? "true" : "false");
    }catch(_){}
  }
  function attachToggle(){
    var b = document.getElementById("ttsToggleBtn");
    if (!b) return;
    try{ b.onclick = null; b.removeAttribute("onclick"); }catch(_){}
    b.addEventListener("click", function(ev){
      ev.preventDefault(); ev.stopPropagation();
      window.ttsEnabled = !window.ttsEnabled;
      try{ localStorage.setItem("tts_on", window.ttsEnabled ? "1" : "0"); }catch(_){}
      // si on vient d'activer, lire tout de suite
      if (window.ttsEnabled) speakCurrent();
      else { try{ window.speechSynthesis && window.speechSynthesis.cancel(); }catch(_){} }
      updateTTSBtn();
    }, {passive:false});
    updateTTSBtn();
  }

  document.addEventListener("DOMContentLoaded", function(){
    attachToggle();
    updateTTSBtn();
  });
})();
</script>
<!-- === /TTS FIX WRAPPER v2 === -->
<script>
// RUNTIME SAFETY: enforce correct modes for requested items
(function(){
  var ONLY_NOTABLE = new Set([32, 33]); // Q33,Q34
  var VERBAL1_FORCE = new Set([19, 30]); // Q20,Q31
  document.addEventListener('DOMContentLoaded', function(){
    try{
      function pruneSet(s, inds){ if(!s||typeof s.delete!=='function') return; inds.forEach(function(i){ s.delete(i); }); }
      pruneSet(window.MIXED_QUESTIONS, ONLY_NOTABLE);
      pruneSet(window.VERBAL2_SET, ONLY_NOTABLE);
      pruneSet(window.VERBAL1_SET, ONLY_NOTABLE);

      if (window.VERBAL1_SET && typeof window.VERBAL1_SET.add==='function') { VERBAL1_FORCE.forEach(function(i){ window.VERBAL1_SET.add(i); }); }
      if (window.NOTABLES_SET && typeof window.NOTABLES_SET.add==='function') {
        ONLY_NOTABLE.forEach(function(i){ window.NOTABLES_SET.add(i); });
        VERBAL1_FORCE.forEach(function(i){ window.NOTABLES_SET.add(i); });
      }
      // Clear any 'mixed' flag on Q33/Q34 if present
      if (Array.isArray(window.questions)){
        ONLY_NOTABLE.forEach(function(i){
          try{ if (window.questions[i] && window.questions[i].mixed) delete window.questions[i].mixed; }catch(_){}
        });
      }
    }catch(_){}
  });
})();
</script>
<script>
// SAFETY: force Q20,Q31 -> VERBAL1 (remove VERBAL2 at runtime)
(function(){
  var V1 = new Set([19, 30]);
  document.addEventListener('DOMContentLoaded', function(){
    try{
      if (window.VERBAL2_SET && typeof window.VERBAL2_SET.delete==='function') {
        V1.forEach(function(i){ window.VERBAL2_SET.delete(i); });
      }
      if (window.VERBAL1_SET && typeof window.VERBAL1_SET.add==='function') {
        V1.forEach(function(i){ window.VERBAL1_SET.add(i); });
      }
      if (window.NOTABLES_SET && typeof window.NOTABLES_SET.add==='function') {
        V1.forEach(function(i){ window.NOTABLES_SET.add(i); });
      }
    }catch(_){}
  });
})();
</script>
<script>
// SAFETY: Force Q20,Q31,Q46,Q48,Q53 -> VERBAL1 (inte alls, kanske, lite, ganska mycket, mycket)
(function(){
  var V1 = new Set([19, 30, 45, 47, 52]);
  document.addEventListener('DOMContentLoaded', function(){
    try{
      // prune VERBAL2
      if (window.VERBAL2_SET && typeof window.VERBAL2_SET.delete==='function'){
        V1.forEach(function(i){ window.VERBAL2_SET.delete(i); });
      }
      // ensure VERBAL1 + NOTABLES
      if (window.VERBAL1_SET && typeof window.VERBAL1_SET.add==='function'){
        V1.forEach(function(i){ window.VERBAL1_SET.add(i); });
      }
      if (window.NOTABLES_SET && typeof window.NOTABLES_SET.add==='function'){
        V1.forEach(function(i){ window.NOTABLES_SET.add(i); });
      }
      // if app uses a label resolver, nothing to do;
      // if it reads per-question flags, ensure no residual 'verbal2' flag is present:
      if (Array.isArray(window.questions)){
        V1.forEach(function(i){
          try{
            if (window.questions[i]){
              if (window.questions[i].verbal2) delete window.questions[i].verbal2;
              window.questions[i].verbal1 = true;
            }
          }catch(_){}
        });
      }
    }catch(_){}
  });
})();
</script>
<script>
// === FIX #1: Restore introduction (page 2) ===
(function(){
  document.addEventListener('DOMContentLoaded', function(){
    try{
      // If app uses a flag to control intro visibility
      window.SHOW_INTRO = true;
      // Try to call a standard intro function if it exists
      if (typeof window.showIntro === "function") {
        try { window.showIntro(); } catch(_){}
      }
      // Otherwise, unhide common intro containers
      var ids = ["introSection","intro","introduction","introPage"];
      ids.forEach(function(id){
        var el = document.getElementById(id);
        if (el){
          try{ el.hidden = false; }catch(_){}
          try{ el.style.display = ""; }catch(_){}
        }
      });
      // Also ensure the step/page variable (if used) starts at intro
      if (typeof window.gotoIntro === "function") {
        try{ window.gotoIntro(); }catch(_){}
      }
    }catch(_){}
  });
})();

// === FIX #2: Force dropdown default to 'Neurologi' (not 'DSM-5') ===
(function(){
  var NEURO_LABELS = ["Neurologi","NEUROLOGIE","Neurology","NEURO"];
  document.addEventListener('DOMContentLoaded', function(){
    try{
      var fSel = document.getElementById("questionnaireSelect") || document.getElementById("formSelect");
      if (fSel){
        var selected = false;
        for (var i=0;i<fSel.options.length;i++){
          var opt = fSel.options[i];
          var t = (opt.text||"").trim();
          var v = (opt.value||"").trim();
          if (NEURO_LABELS.indexOf(t)>-1 || NEURO_LABELS.indexOf(v)>-1){
            fSel.selectedIndex = i;
            selected = true;
            break;
          }
        }
        if (!selected){
          // fallback: set value to exact string
          fSel.value = "Neurologi";
        }
        // Trigger change to update dependent UI
        try{
          var evt = new Event('change', {bubbles:true});
          fSel.dispatchEvent(evt);
        }catch(_){}
      }
    }catch(_){}
  });
})();
</script>
<style>
#forcedIntroOverlay{
  position: fixed; inset: 0; background: rgba(0,0,0,0.35);
  display: none; align-items: center; justify-content: center; z-index: 99999;
}
#forcedIntro{
  background: #fff; max-width: 820px; width: 92%; padding: 24px 28px;
  border-radius: 14px; box-shadow: 0 10px 30px rgba(0,0,0,0.25);
  font-size: 16px; line-height: 1.5;
}
#forcedIntro h2{ margin-top: 0; margin-bottom: 10px; }
#forcedIntro .actions{ margin-top: 18px; text-align: right; }
#forcedIntro button{
  padding: 10px 16px; border: none; border-radius: 10px; cursor: pointer;
}
#forcedIntro .primary{ background:#0b5ed7; color:#fff; }
</style>
<div aria-hidden="true" id="forcedIntroOverlay">
<div aria-labelledby="forcedIntroTitle" id="forcedIntro" role="dialog">
<h2 id="forcedIntroTitle">Introduktion</h2>
<p>Detta frågeformulär är anonymt och konfidentiellt.</p>
<ul>
<li>Svara med dina egna ord, tryck sedan <b>Enter</b> för att validera.</li>
<li>För skale-frågor: välj <b>1–5</b> och tryck Enter/OK.</li>
<li>Du kan klicka på <b>Korrigera</b> för att skriva om eller gå till föregående fråga.</li>
<li>Om röst är aktiverad kan du säga <b>STOPP</b> för att pausa.</li>
<li>Tack för att du svarar så ärligt som möjligt.</li>
</ul>
<div class="actions">
<button class="primary" id="forcedIntroStartBtn">Starta</button>
</div>
</div>
</div>
<script>
// INTRO GATE: show an introduction screen before first question regardless of internal flags.
(function(){
  var shown = false;
  function showOverlay(){
    var ov = document.getElementById('forcedIntroOverlay');
    if(ov){ ov.style.display = 'flex'; ov.setAttribute('aria-hidden','false'); }
  }
  function hideOverlay(){
    var ov = document.getElementById('forcedIntroOverlay');
    if(ov){ ov.style.display = 'none'; ov.setAttribute('aria-hidden','true'); }
  }
  document.addEventListener('DOMContentLoaded', function(){
    try{
      var btn = document.getElementById('forcedIntroStartBtn');
      if(btn){
        btn.addEventListener('click', function(){
          hideOverlay();
          shown = true;
          if (window.__origShowQuestion && typeof window.__pendingFirstIndex === 'number'){
            try{ window.__origShowQuestion(window.__pendingFirstIndex); }catch(_){}
          }
        });
      }
      if (typeof window.showQuestion === 'function'){
        // Monkey-patch
        window.__origShowQuestion = window.showQuestion;
        window.showQuestion = function(i){
          if(!shown){
            window.__pendingFirstIndex = i;
            showOverlay();
            return;
          }
          return window.__origShowQuestion(i);
        };
      }else{
        // Fallback: if no showQuestion, just show intro immediately
        showOverlay();
      }
    }catch(_){}
  });
})();
</script>
<script>
// === INTRO PAGE-2 PATCH (align with test9 behavior) ===
(function(){
  function show(el){ if(el){ el.style.display = ""; el.hidden = false; } }
  function hide(el){ if(el){ el.style.display = "none"; el.hidden = true; } }
  function setIntroText(){
    try{
      var m = (window.messagesInterface && window.currentLang && window.messagesInterface[window.currentLang]) || {};
      var intro = m.intro || "Detta frågeformulär är anonymt. Svara i lugn och ro.\nDu kan pausa när som helst.";
      var p = document.getElementById("introText");
      if (p && (!p.textContent || !p.textContent.trim())) p.textContent = intro;
      var h2 = document.querySelector("#introScreen h2");
      if (h2) h2.textContent = (m.introTitle || "Introduktion");
      var lbl = document.getElementById("labelCode"); if (lbl) lbl.textContent = (m.codeLabel || "Ange din fyrsiffriga kod:");
      var startBtn = document.getElementById("startBtn"); if (startBtn) startBtn.textContent = (m.start || "Starta");
    }catch(_){}
  }

  document.addEventListener("DOMContentLoaded", function(){
    try{
      // Neutralize any "overlay intro" to avoid page 3 behavior
      var ov = document.getElementById("forcedIntroOverlay");
      if (ov) { ov.parentNode.removeChild(ov); }

      // Force the "Continue" button on the menu to go to INTRO (page 2)
      var nextBtn = document.getElementById("nextLangBtn");
      if (nextBtn){
        nextBtn.addEventListener("click", function(e){
          try{
            // Prevent any handler that would jump directly to main
            e.stopImmediatePropagation && e.stopImmediatePropagation();
          }catch(_){}
          try{
            var menu = document.getElementById("menuScreen");
            var intro = document.getElementById("introScreen");
            hide(menu); show(intro);
            // Fill intro texts
            setIntroText();
            // Focus code input if present
            var ci = document.getElementById("codeInput"); if (ci) try{ ci.focus(); }catch(_){}
          }catch(_){}
        }, true); // capture to run before other listeners
      }

      // Ensure that clicking "Start" goes to main
      var start = document.getElementById("startBtn");
      if (start){
        start.addEventListener("click", function(){
          try{
            var intro = document.getElementById("introScreen");
            var main  = document.getElementById("main");
            hide(intro); show(main);
          }catch(_){}
        }, false);
      }
    }catch(_){}
  });
})();
</script>
<script>
// === DSM-LIKE FLOW PATCH (menu -> intro -> main) ===
(function(){
  function $(id){ return document.getElementById(id); }
  function show(el){ if(el){ el.style.display = ""; el.hidden = false; } }
  function hide(el){ if(el){ el.style.display = "none"; el.hidden = true; } }

  function getIntroStrings(){
    var lang = window.currentLang || "Svenska";
    var M = (window.messagesInterface && window.messagesInterface[lang]) || {};
    return {
      title: (M.introTitle || "Introduktion"),
      intro: (M.intro || "Detta frågeformulär är anonymt och konfidentiellt.\nSvara i lugn och ro, du kan pausa när som helst."),
      codeLabel: (M.codeLabel || "Ange din fyrsiffriga kod:"),
      start: (M.start || "Starta")
    };
  }

  function applyIntroTexts(){
    var S = getIntroStrings();
    var introEl = $("introText");
    var h2 = $("introScreen") ? $("introScreen").querySelector("h2") : null;
    var codeLbl = $("labelCode");
    var startBtn = $("startBtn");
    if (h2) h2.textContent = S.title;
    if (introEl) introEl.textContent = S.intro;
    if (codeLbl) codeLbl.textContent = S.codeLabel;
    if (startBtn) startBtn.textContent = S.start;
  }

  function showIntro(){
    // DSM-like: hide menu, show intro (page2), populate text
    hide($("menuScreen"));
    show($("introScreen"));
    applyIntroTexts();
    try{ $("codeInput") && $("codeInput").focus(); }catch(_){}
  }

  function showMain(){
    hide($("introScreen"));
    show($("main"));
    // If the app requires an initial question shown:
    if (typeof window.showQuestion === "function"){
      if (typeof window.currentQuestion !== "number") window.currentQuestion = 0;
      try{ window.showQuestion(window.currentQuestion); }catch(_){}
    }
  }

  document.addEventListener("DOMContentLoaded", function(){
    // Ensure intro overlay (if any) is removed to not steal the flow
    var ov = $("forcedIntroOverlay"); if (ov && ov.parentNode) try{ ov.parentNode.removeChild(ov); }catch(_){}

    // Wire buttons like DSM
    var nextBtn = $("nextLangBtn");
    if (nextBtn){
      nextBtn.addEventListener("click", function(ev){
        // let DSM handlers run but enforce intro screen after them
        setTimeout(showIntro, 0);
      }, true);
    }
    var start = $("startBtn");
    if (start){
      start.addEventListener("click", function(ev){
        ev.preventDefault();
        showMain();
      });
    }

    // If some script jumped straight to main already, push back to intro once:
    if ($("main") && $("main").style.display !== "none" && $("introScreen") && $("introScreen").style.display === "none"){
      showIntro();
    }
  });
})();
</script>
<script>
// === HARD PAGE-FLOW ENFORCER (menu -> intro -> main) ===
(function(){
  function $(id){ return document.getElementById(id); }
  function show(el){ if(el){ el.style.removeProperty('display'); el.hidden = false; } }
  function hide(el){ if(el){ el.style.display = 'none'; el.hidden = true; } }
  function getMIIntro(){
    try{
      var lang = window.currentLang || "Svenska";
      var M = (window.messagesInterface && window.messagesInterface[lang]) || {};
      return {
        title: M.introTitle || "Introduktion",
        text:  M.intro || "Detta frågeformulär är anonymt och konfidentiellt.\n• Svara med dina egna ord och tryck Enter för att validera.\n• För skale-frågor, välj 1–5 och tryck Enter/OK.\n• Du kan klicka ”Korrigera” för att skriva om eller gå tillbaka.\n• Säg STOPP (om röst är aktiverad) för att pausa.\nTack för att du svarar så ärligt som möjligt.",
        code:  M.codeLabel || "Ange din fyrsiffriga kod:",
        start: M.start || "Starta"
      };
    }catch(_){ return {title:"Introduktion", text:"", code:"", start:"Starta"}; }
  }
  function fillIntro(){
    var S = getMIIntro();
    var h2 = $("introScreen") ? $("introScreen").querySelector("h2") : null;
    if (h2) h2.textContent = S.title;
    var p = $("introText"); if (p) p.textContent = S.text;
    var lbl = $("labelCode"); if (lbl) lbl.textContent = S.code;
    var sb = $("startBtn"); if (sb) sb.textContent = S.start;
  }

  document.addEventListener("DOMContentLoaded", function(){
    try{
      // Initial states
      show($("menuScreen"));
      hide($("introScreen"));
      hide($("main"));

      // Wire menu -> intro
      var next = $("nextLangBtn");
      if (next){
        next.addEventListener("click", function(ev){
          ev.preventDefault(); ev.stopImmediatePropagation();
          fillIntro();
          hide($("menuScreen"));
          show($("introScreen"));
          try{ $("codeInput") && $("codeInput").focus(); }catch(_){}
        }, true);
      }

      // Wire intro -> main
      var start = $("startBtn");
      if (start){
        start.addEventListener("click", function(ev){
          ev.preventDefault(); ev.stopImmediatePropagation();
          hide($("introScreen"));
          show($("main"));
          // Kick first question if needed
          try{
            if (typeof window.currentQuestion!=='number') window.currentQuestion = 0;
            if (typeof window.showQuestion==='function') window.showQuestion(window.currentQuestion);
          }catch(_){}
        }, true);
      }

      // Safety: if something shows main directly, push back to intro once
      setTimeout(function(){
        var ms = $("menuScreen"), ins=$("introScreen"), mn=$("main");
        if (mn && ins && ms && mn.style.display!=="none" && ins.style.display==="none"){
          // force intro
          hide(ms); show(ins); hide(mn); fillIntro();
        }
      }, 50);
    }catch(_){}
  });
})();
</script>
<script>
(function(){
  function $(id){ return document.getElementById(id); }
  function show(el){ if(el){ el.style.display = ""; el.hidden = false; } }
  function hide(el){ if(el){ el.style.display = "none"; el.hidden = true; } }
  document.addEventListener("DOMContentLoaded", function(){
    try{
      var next = $("nextLangBtn");
      if (next){
        next.onclick = function(ev){
          try{ ev.preventDefault(); }catch(_){}
          hide($("menuScreen"));
          show($("introScreen"));
          return false;
        };
      }
      var start = $("startBtn");
      if (start){
        start.onclick = function(ev){
          try{ ev.preventDefault(); }catch(_){}
          hide($("introScreen"));
          show($("main"));
          if (typeof window.currentQuestion!=='number') window.currentQuestion = 0;
          if (typeof window.showQuestion==='function') try{ window.showQuestion(window.currentQuestion); }catch(_){}
          return false;
        };
      }
      // Ensure initial visibility
      show($("menuScreen"));
      hide($("introScreen"));
      hide($("main"));
    }catch(_){}
  });
})();
</script>
<script>
(function(){
  function $(id){ return document.getElementById(id); }
  function show(el){ if(el){ el.style.display = ""; el.hidden = false; } }
  function hide(el){ if(el){ el.style.display = "none"; el.hidden = true; } }
  document.addEventListener("DOMContentLoaded", function(){
    // Initial states
    show($("menuScreen")); hide($("introScreen")); hide($("main"));
    var next = $("nextLangBtn");
    if (next){
      next.onclick = function(ev){ try{ev.preventDefault();}catch(_){}
        hide($("menuScreen")); show($("introScreen")); return false; };
    }
    var start = $("startBtn");
    if (start){
      start.onclick = function(ev){ try{ev.preventDefault();}catch(_){}
        hide($("introScreen")); show($("main"));
        if (typeof window.currentQuestion!=='number') window.currentQuestion = 0;
        if (typeof window.showQuestion==='function') try{ window.showQuestion(window.currentQuestion); }catch(_){}
        return false; };
    }
  });
})();
</script>
<script>
// === HARD-WIRE: Intro (page 2) -> Main (page 3) ===
(function(){
  function $(id){ return document.getElementById(id); }
  function show(el){ if(el){ el.style.removeProperty('display'); el.hidden = false; } }
  function hide(el){ if(el){ el.style.display = 'none'; el.hidden = true; } }

  document.addEventListener('DOMContentLoaded', function(){
    try{
      var start = $('startBtn');
      if (start){
        // Capture phase to override any previous handlers
        start.addEventListener('click', function(ev){
          try{ ev.preventDefault(); ev.stopImmediatePropagation(); }catch(_){}
          try{
            // Hide intro, show main
            hide($('introScreen'));
            var main = $('main') || $('questionnaire') || $('content');
            show(main);

            // Initialize question flow
            if (typeof window.currentQuestion !== 'number' || window.currentQuestion < 0){
              window.currentQuestion = 0;
            }
            if (typeof window.showQuestion === 'function'){
              try { window.showQuestion(window.currentQuestion); } catch(_){}
            } else {
              // Fallback: ensure first question container (if present) becomes visible
              var q = (window.questions || []);
              if (q.length > 0){
                var qEl = document.querySelector('[data-question-index="0"]') || document.querySelector('.question');
                if (qEl){ qEl.style.removeProperty('display'); }
              }
            }
          }catch(_){}
          return false;
        }, true);
      }

      // Also ensure the "Continue" button goes to Intro (page 2)
      var next = $('nextLangBtn');
      if (next){
        next.addEventListener('click', function(ev){
          try{ ev.preventDefault(); ev.stopImmediatePropagation(); }catch(_){}
          hide($('menuScreen'));
          show($('introScreen'));
          return false;
        }, true);
      }

      // Initial visibility sanity
      var menu = $('menuScreen'), intro = $('introScreen'), main = $('main') || $('questionnaire') || $('content');
      if (menu && intro && main){
        menu.style.removeProperty('display');
        intro.style.display = 'none';
        main.style.display = 'none';
        menu.hidden = false; intro.hidden = true; main.hidden = true;
      }
    }catch(_){}
  });
})();
</script>
<script>
// === START OVERRIDE (hard) ===
(function(){
  function $(id){ return document.getElementById(id); }
  function show(el){ if(el){ el.style.removeProperty('display'); el.hidden = false; } }
  function hide(el){ if(el){ el.style.display = 'none'; el.hidden = true; } }
  function goMain(){
    hide($('introScreen'));
    var main = $('main') || $('questionnaire') || $('content');
    show(main);
    if (typeof window.currentQuestion !== 'number' || window.currentQuestion < 0) window.currentQuestion = 0;
    // Try multiple times in case UI initializes late
    var tries = 0;
    function tryShow(){
      tries++;
      try{
        if (typeof window.showQuestion === 'function'){
          window.showQuestion(window.currentQuestion);
          return; // success
        }
      }catch(e){}
      if (tries < 10) setTimeout(tryShow, 50);
    }
    tryShow();
  }
  document.addEventListener('DOMContentLoaded', function(){
    try{
      var btn = $('startBtn');
      if (!btn) return;
      // Replace node to drop existing listeners
      var clone = btn.cloneNode(true);
      btn.parentNode.replaceChild(clone, btn);
      clone.addEventListener('click', function(ev){
        try{ ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); }catch(_){}
        goMain();
        return false;
      }, true);
      // Also ensure "Enter" in code input triggers the same
      var ci = $('codeInput');
      if (ci){
        ci.addEventListener('keydown', function(e){
  if (e.key === 'Enter'){
    e.preventDefault();
    var v = (ci.value||'').trim();
    if (/^\d{4}$/.test(v)) { goMain(); }
    else {
      var em = document.getElementById('introErrorMsg');
      if (em){ em.textContent = (window.MI && ((MI['Svenska'] && MI['Svenska'].errorCode) || (MI['Français'] && MI['Français'].errorCode) || (MI['English'] && MI['English'].errorCode))) || 'Please enter a valid 4-digit code.'; }
      try{ ci.focus(); if (ci.select) ci.select(); }catch(_){}
    }
  }
});
      }
    }catch(_){}
  });
})();
</script>
<script>
// === QUESTION HEADER MIRROR ===
(function(){
  function $(id){ return document.getElementById(id); }
  function setHeader(){
    try{
      var qidx = (typeof window.currentQuestion==='number') ? window.currentQuestion : 0;
      var q = (window.questions && window.questions[qidx]) || {};
      if ($('questionText')) $('questionText').textContent = q.text || '';
      if ($('questionNum')) $('questionNum').textContent = (qidx+1) + '/' + (window.questions? window.questions.length : '');
      if ($('sectionNum')) $('sectionNum').textContent = q.section ? ('Avsnitt ' + q.section) : '';
    }catch(_){}
  }
  document.addEventListener('DOMContentLoaded', function(){
    try{
      // Initial fill
      setTimeout(setHeader, 10);
      // Patch showQuestion() to refresh header after each render
      if (typeof window.showQuestion === 'function'){
        var __orig = window.showQuestion;
        window.showQuestion = function(){
          try{ var r = __orig.apply(this, arguments); }catch(e){}
          try{ setHeader(); }catch(_){}
          return r;
        };
      }
      // Also update on Confirm click in case flow doesn't call showQuestion
      var ok = document.getElementById('validerBtn') || document.getElementById('okBtn') || document.getElementById('confirmBtn');
      if (ok){
        ok.addEventListener('click', function(){
          setTimeout(setHeader, 20);
        }, true);
      }
    }catch(_){}
  });
})();
</script>
<script>
// === QUESTIONS WAITER ===
(function(){
  function $(id){ return document.getElementById(id); }
  function ready(){ return Array.isArray(window.questions) && window.questions.length>0; }
  function setHeader(idx){
    try{
      var qidx = (typeof idx==='number') ? idx : (typeof window.currentQuestion==='number' ? window.currentQuestion : 0);
      var q = (window.questions && window.questions[qidx]) || {};
      if ($('questionText')) $('questionText').textContent = q.text || '';
      if ($('questionNum')) $('questionNum').textContent = (qidx+1) + '/' + (window.questions? window.questions.length : '');
      if ($('sectionNum')) $('sectionNum').textContent = q.section ? ('Avsnitt ' + q.section) : '';
    }catch(_){}
  }
  function kick(){
    try{
      if (typeof window.currentQuestion!=='number' || window.currentQuestion < 0) window.currentQuestion = 0;
      if (typeof window.showQuestion === 'function'){
        window.showQuestion(window.currentQuestion);
      }
      setHeader(window.currentQuestion);
    }catch(_){}
  }
  document.addEventListener('DOMContentLoaded', function(){
    // Only run on page-3
    var main = $('main') || $('questionnaire') || $('content');
    if (!main) return;
    var attempts = 0;
    (function loop(){
      attempts++;
      if (ready()){
        kick();
        return;
      }
      if (attempts < 40) return setTimeout(loop, 100);
    })();
    // Also wire Starta in case the wait should begin after intro
    var start = $('startBtn');
    if (start){
      start.addEventListener('click', function(){
        // Guard: require 4-digit code before starting
        try {
          var ci = document.getElementById('codeInput');
          if (ci) {
            var v = (ci.value||'').trim();
            if (!/^\d{4}$/.test(v)){
              var em = document.getElementById('introErrorMsg');
              if (em){ em.textContent = (window.MI && ((MI['Svenska'] && MI['Svenska'].errorCode) || (MI['Français'] && MI['Français'].errorCode) || (MI['English'] && MI['English'].errorCode))) || 'Please enter a valid 4-digit code.'; }
              try{ ci.focus(); if (ci.select) ci.select(); }catch(_){}
              return;
            }
          }
        } catch(_){}
    
        var tries = 0;
        (function loop2(){
          tries++;
          if (ready()){ kick(); return; }
          if (tries < 40) setTimeout(loop2, 100);
        })();
      }, true);
    }
  });
})();
</script>
<script>
// === NAV & FOCUS PATCH ===
(function(){
  function $(id){ return document.getElementById(id); }
  function focusAnswer(){
    try{
      var el = $('answerInput');
      if (!el){
        // fallback: first textarea or input[type=text] inside the answer zone
        var zone = $('answerZone') || document;
        el = zone.querySelector('textarea, input[type="text"], input[type="search"]');
      }
      if (el){
        el.focus();
        try{
          // place cursor at end
          var v = el.value || "";
          el.setSelectionRange(v.length, v.length);
        }catch(_){}
      }
    }catch(_){}
  }
  function attachEnterHandler(){
    try{
      var el = $('answerInput') || document.querySelector('textarea, input[type="text"], input[type="search"]');
      if (!el || el.__enterHandlerAttached) return;
      el.__enterHandlerAttached = true;
      el.addEventListener('keydown', function(e){
        if (e.key === 'Enter' && !e.shiftKey && !e.altKey && !e.ctrlKey && !e.metaKey){
          e.preventDefault();
          var btn = $('validerBtn') || $('okBtn') || $('confirmBtn');
          if (btn){ btn.click(); }
        }
      });
    }catch(_){}
  }
  function attachConfirmFallback(){
    try{
      var btn = $('validerBtn') || $('okBtn') || $('confirmBtn');
      if (!btn || btn.__fallbackAttached) return;
      btn.__fallbackAttached = true;
      btn.addEventListener('click', function(){
        // Let the app handle navigation first
        var before = (typeof window.currentQuestion==='number') ? window.currentQuestion : 0;
        setTimeout(function(){
          try{
            var after = (typeof window.currentQuestion==='number') ? window.currentQuestion : 0;
            if (after === before){
              // App didn't advance; do a safe fallback
              var next = Math.min(before + 1, (window.questions ? window.questions.length-1 : before));
              if (next !== before && typeof window.showQuestion === 'function'){
                window.currentQuestion = next;
                window.showQuestion(next);
              }
            }
          }catch(_){}
        }, 80);
      }, true);
    }catch(_){}
  }

  // Patch showQuestion to always focus input + handlers
  document.addEventListener('DOMContentLoaded', function(){
    try{
      if (typeof window.showQuestion === 'function' && !window.__showQuestionPatched){
        var __orig = window.showQuestion;
        window.showQuestion = function(){
          var r;
          try{ r = __orig.apply(this, arguments); }catch(_){}
          try{
            // After render, focus & handlers
            setTimeout(function(){
              focusAnswer();
              attachEnterHandler();
              attachConfirmFallback();
            }, 25);
          }catch(_){}
          return r;
        };
        window.__showQuestionPatched = true;
      }
      // Also run once on initial page-3 open
      setTimeout(function(){
        focusAnswer();
        attachEnterHandler();
        attachConfirmFallback();
      }, 100);
    }catch(_){}
  });
})();
</script>
<script>
// === AUTO-CLEAR ANSWER ON NEXT QUESTION ===
(function(){
  function $(id){ return document.getElementById(id); }
  function clearAnswer(){
    try{
      var zone = $('answerZone') || document;
      var t = $('answerInput') || zone.querySelector('textarea, input[type="text"], input[type="search"]');
      if (t){ t.value = ""; }
      // Clear common widgets
      var slider = zone.querySelector('input[type="range"]'); if (slider){ slider.value = slider.min || 0; }
      var radios = zone.querySelectorAll('input[type="radio"]'); if (radios && radios.length){ radios.forEach(function(r){ r.checked = false; }); }
      var checks = zone.querySelectorAll('input[type="checkbox"]'); if (checks && checks.length){ checks.forEach(function(c){ c.checked = false; }); }
    }catch(_){}
  }
  // Patch showQuestion to clear the input each time a new question renders
  document.addEventListener('DOMContentLoaded', function(){
    try{
      if (typeof window.showQuestion === 'function' && !window.__clearPatched){
        var __orig = window.showQuestion;
        window.showQuestion = function(){
          var r;
          try{ r = __orig.apply(this, arguments); }catch(_){}
          try{
            // Clear the field shortly after render to avoid racing with templates
            setTimeout(function(){ clearAnswer(); }, 10);
          }catch(_){}
          return r;
        };
        window.__clearPatched = true;
      }
      // Also clear right after a successful confirmation
      var ok = $('validerBtn') || $('okBtn') || $('confirmBtn');
      if (ok){
        ok.addEventListener('click', function(){
          setTimeout(function(){ clearAnswer(); }, 80);
        }, true);
      }
    }catch(_){}
  });
})();
</script>
<script>
// === FORCE HEADER TITLES: add "Neurologi" next to "Frågeformulär" on all screens ===
(function(){
  function setHeader(){
    try{
      var hMain = document.getElementById('mainTitle');
      if (hMain){
        var t = (hMain.textContent||'').trim();
        if (!/Neurologi/i.test(t)){
          if (/Frågeformulär/i.test(t)){
            hMain.textContent = 'Frågeformulär Neurologi';
          } else {
            hMain.textContent = (t ? t + ' ' : '') + 'Neurologi';
          }
        }
      }
      var titleEl = document.querySelector('title#pageTitle') || document.querySelector('title');
      if (titleEl){
        var txt = titleEl.textContent || 'Questionnaire';
        if (!/Neurologi/i.test(txt)){
          var m = txt.match(/(Version[^]*)$/i);
          var suffix = m ? (' - ' + m[1]) : '';
          titleEl.textContent = 'Frågeformulär Neurologi' + suffix;
        }
      }
    }catch(_){}
  }
  document.addEventListener('DOMContentLoaded', setHeader);
  window.addEventListener('load', setHeader);
})();
</script>
<script>
// === KORRIGERA ROBUST FALLBACK ===
(function(){
  function getDisplayedIndex(){
    var qn = document.getElementById('questionNum');
    var idx = (window.currentQuestion|0);
    try{
      if (qn){
        var m = qn.textContent.match(/(\d+)\s*\/\s*(\d+)/);
        if (m) idx = parseInt(m[1],10)-1;
      }
    }catch(_){}
    return idx;
  }
  function goTo(idx){
    try{
      if (typeof window.showQuestion === 'function'){
        window.currentQuestion = Math.max(0, Math.min(idx, (window.questions?window.questions.length-1:idx)));
        window.showQuestion(window.currentQuestion);
      }
    }catch(_){}
  }
  function ensureCorriger(){
    var btn = document.getElementById('corrigerBtn');
    if (!btn){
      var candidates = Array.from(document.querySelectorAll('button')).filter(function(b){
        var t = (b.textContent||'').trim().toLowerCase();
        return t === 'korrigera' || t === 'corriger' || t === 'correct' || t === 'korigera';
      });
      if (candidates.length) btn = candidates[0];
    }
    if (!btn || btn.__korrigeraAttached) return;
    btn.__korrigeraAttached = true;

    var stage = 0; // 0 = rewrite current; 1 = previous question
    btn.addEventListener('click', function(ev){
      try{ ev.preventDefault(); ev.stopPropagation(); }catch(_){}
      try{ var sc=document.getElementById('scoreContainer'); if(sc) sc.style.display='none'; }catch(_){}
      try{ if (window.recognition && window.listening){ recognition.abort&&recognition.abort(); recognition.stop&&recognition.stop(); window.listening=false; } }catch(_){}
      if (stage === 0){
        try{
          var f = document.getElementById('answerInput') || document.querySelector('textarea, input[type="text"]');
          if (f){ f.disabled=false; f.style.display='block'; f.value=''; setTimeout(function(){ try{f.focus();}catch(_){} }, 30); }
        }catch(_){}
        stage = 1;
      } else {
        var idx = getDisplayedIndex();
        goTo(idx-1);
        stage = 0;
      }
    }, true);
  }
  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(ensureCorriger, 100);
    if (typeof window.showQuestion === 'function' && !window.__corrigerHooked){
      var _orig = window.showQuestion;
      window.showQuestion = function(){
        var r; try{ r=_orig.apply(this, arguments);}catch(_){}
        setTimeout(ensureCorriger, 30);
        return r;
      };
      window.__corrigerHooked = true;
    }
  });
})();
</script>
<script>
// === KORRIGERA — HARD OVERRIDE ===
(function(){
  function $(id){ return document.getElementById(id); }
  function findKorrigera(){
    var byId = $('corrigerBtn') || $('korrigeraBtn') || $('btnCorriger');
    if (byId) return byId;
    var btns = Array.from(document.querySelectorAll('button, a[role="button"]'));
    for (var i=0;i<btns.length;i++){
      var t = (btns[i].textContent||"").trim().toLowerCase();
      if (t === "korrigera" || t === "corriger" || t === "corrige" || t === "corrigerar"){
        return btns[i];
      }
    }
    return null;
  }
  function goTo(idx){
    try{
      var max = (window.questions? window.questions.length-1 : 0);
      idx = Math.max(0, Math.min(idx, max));
      if (typeof window.showQuestion === 'function'){
        window.currentQuestion = idx;
        window.showQuestion(idx);
        // focus input for immediate rewrite
        setTimeout(function(){
          var f = $('answerInput') || document.querySelector('textarea, input[type="text"], input[type="search"]');
          if (f){ try{ f.disabled=false; f.style.display='block'; f.focus(); }catch(_){ } }
        }, 30);
      }
    }catch(_){}
  }
  function ensure(){
    var btn = findKorrigera();
    if (!btn) return;
    if (btn.__hardAttached) return;
    btn.__hardAttached = true;
    // Replace node to drop previous conflicting listeners
    var clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.removeAttribute('disabled');
    clone.addEventListener('click', function(ev){
      try{ ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); }catch(_){}
      try{
        // Preferred behavior: go back one question to correct previous answer.
        var idx = (typeof window.currentQuestion==='number') ? window.currentQuestion : 0;
        // If on first question, just clear current to retype
        if (idx > 0) {
          goTo(idx-1);
        } else {
          var f = $('answerInput') || document.querySelector('textarea, input[type="text"]');
          if (f){ f.value=""; try{ f.focus(); }catch(_){ } }
        }
      }catch(_){}
      return false;
    }, true);
  }
  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(ensure, 80);
    // Re-ensure after each render
    if (typeof window.showQuestion === 'function' && !window.__korrigeraRehook){
      var _orig = window.showQuestion;
      window.showQuestion = function(){
        var r; try{ r=_orig.apply(this, arguments); }catch(_){}
        setTimeout(ensure, 30);
        return r;
      };
      window.__korrigeraRehook = true;
    }
  });
})();
</script>
<script>
// === KORRIGERA — COOPERATIVE HANDLER ===
(function(){
  function $(id){ return document.getElementById(id); }
  function findBtn(){
    return $('corrigerBtn') || $('korrigeraBtn') || $('btnCorriger') ||
      Array.from(document.querySelectorAll('button, a[role="button"]'))
        .find(b => (/^(korrigera|corriger|corrige|corrigerar)$/i).test((b.textContent||'').trim()));
  }
  function focusAnswer(){
    var f = $('answerInput') || document.querySelector('textarea, input[type="text"], input[type="search"]');
    if (f){ try{ f.disabled=false; f.style.display='block'; f.focus(); }catch(_){} }
  }
  function goPrev(){
    try{
      var idx = (typeof window.currentQuestion==='number') ? window.currentQuestion : 0;
      if (idx > 0){
        window.currentQuestion = idx - 1;
        if (typeof window.showQuestion==='function'){ window.showQuestion(window.currentQuestion); }
        // clear field for rewrite
        setTimeout(function(){
          var f = $('answerInput') || document.querySelector('textarea, input[type="text"], input[type="search"]');
          if (f){ f.value = ""; try{ f.focus(); }catch(_){} }
        }, 30);
      } else {
        // on first question, just clear current
        setTimeout(function(){
          var f = $('answerInput') || document.querySelector('textarea, input[type="text"], input[type="search"]');
          if (f){ f.value = ""; try{ f.focus(); }catch(_){} }
        }, 30);
      }
    }catch(_){}
  }
  function attach(){
    var btn = findBtn();
    if (!btn || btn.__korrigeraCoop) return;
    btn.__korrigeraCoop = true;
    btn.removeAttribute('disabled');

    btn.addEventListener('click', function(ev){
      // Cooperative: do NOT stop propagation; let app handlers run first.
      var before = (typeof window.currentQuestion==='number') ? window.currentQuestion : 0;
      setTimeout(function(){
        try{
          var after = (typeof window.currentQuestion==='number') ? window.currentQuestion : 0;
          // If nothing changed (no navigation), apply our fallback
          if (after === before){
            goPrev();
          } else {
            // App navigated; just ensure focus
            setTimeout(focusAnswer, 30);
          }
        }catch(_){ goPrev(); }
      }, 40);
    }, false);
  }

  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(attach, 100);
    if (typeof window.showQuestion==='function' && !window.__korrigeraCoopHooked){
      var _orig = window.showQuestion;
      window.showQuestion = function(){
        var r; try{ r=_orig.apply(this, arguments); }catch(_){}
        setTimeout(attach, 20);
        return r;
      };
      window.__korrigeraCoopHooked = true;
    }
  });
})();
</script>
<script>
// === KORRIGERA — MINIMAL COOPERATIVE FALLBACK (no node replacement) ===
(function(){
  function $(id){ return document.getElementById(id); }
  function focusAndClear(){
    var f = $('answerInput') || document.querySelector('textarea, input[type="text"], input[type="search"]');
    if (f){ try{ f.value=""; f.disabled=false; f.style.display=""; f.focus(); }catch(_){ } }
  }
  function attach(){
    var btn = $('corrigerBtn') || $('korrigeraBtn') || $('btnCorriger') ||
      Array.from(document.querySelectorAll('button, a[role="button"]')).find(function(b){
        var t=(b.textContent||"").trim().toLowerCase();
        return t==="korrigera"||t==="corriger"||t==="corrige"||t==="corrigerar";
      });
    if (!btn || btn.__minimalCorr) return;
    btn.__minimalCorr = true;

    btn.addEventListener('click', function(){
      // Let native handler run first; then fallback if nothing changed
      var before = (typeof window.currentQuestion==='number') ? window.currentQuestion : 0;
      setTimeout(function(){
        try{
          var after = (typeof window.currentQuestion==='number') ? window.currentQuestion : before;
          if (after === before){
            // Fallback: go to previous (using showQuestion() signature without args)
            if (before > 0){
              window.currentQuestion = before - 1;
              if (typeof window.showQuestion === 'function'){ try{ window.showQuestion(); }catch(_){ } }
              setTimeout(focusAndClear, 40);
            } else {
              // On first question, just clear & focus
              focusAndClear();
            }
          } else {
            // Native handler navigated; ensure field is editable & focused
            setTimeout(focusAndClear, 40);
          }
        }catch(_){}
      }, 40);
    }, false);
  }
  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(attach, 120);
    if (typeof window.showQuestion==='function' && !window.__minimalCorrHook){
      var _orig = window.showQuestion;
      window.showQuestion = function(){
        var r; try{ r=_orig.apply(this, arguments);}catch(_){}
        setTimeout(attach, 30);
        return r;
      };
      window.__minimalCorrHook = true;
    }
  });
})();
</script>


<script>
(function(){
  try { window.NOTABLES_SET = new Set([]); } catch(_){}
  try { window.VERBAL1_SET = new Set([]); } catch(_){}
  try { window.VERBAL2_SET = new Set([]); } catch(_){}
  try { if (Array.isArray(window.MIXED_QUESTIONS)) window.MIXED_QUESTIONS.length = 0; } catch(_){}
  try { window.getScaleTypeForQuestion = function(){ return 'text'; }; } catch(_){}
  function ensureTextUI(){
    try{
      var ans = document.getElementById("answerInput"); if (ans){ ans.disabled=false; ans.style.display=""; }
      var sc = document.getElementById("scoreContainer"); if (sc){ sc.style.display="none"; sc.hidden=true; }
    }catch(_){}
  }
  if (document.readyState === "loading"){ document.addEventListener("DOMContentLoaded", ensureTextUI); } else { ensureTextUI(); }
  // keep UI consistent after renders without touching goNext/showQuestion logic
  document.addEventListener("DOMContentLoaded", function(){
    var mo = new MutationObserver(function(){ ensureTextUI(); });
    try{ mo.observe(document.body, {childList:true, subtree:true}); }catch(_){}
  });
})();
</script>


<section id="summary" style="display:none;">
  <h2 id="summaryTitle">Sammanfattning och korrigering</h2>
  <p><strong id="summaryCodeLabel">Formulärkod :</strong> <span id="resumeCode"></span></p>
  <ul id="answersList"></ul>
  <label id="globalCommentLabel" for="globalComment">Kommentarer</label>
  <textarea id="globalComment" placeholder="Din allmänna kommentar…"></textarea>
  <br>
  <button id="pdfBtn">Exportera PDF</button>
  <button id="copyBtn">Kopiera</button>
  <button id="closeBtn">Slutför</button>
</section>



<script>
(function(){
  function byId(id){ return document.getElementById(id); }
  window.showSummary = function(){
    var main = byId("main"); if (main){ main.style.display="none"; }
    var sum = byId("summary"); if (sum){ sum.style.display="block"; }
    var code = byId("resumeCode"); if (code){ code.textContent = (window.userCode||""); }
    var ul = byId("answersList"); if (ul){ ul.innerHTML=""; }
    try{
      (window.questions||[]).forEach(function(q,i){
        var li = document.createElement("li");
        var ans = (window.answers && window.answers[i]!=null) ? window.answers[i] : "";
        li.innerHTML = "<b>"+ (q.text||('Fråga '+(i+1))) +"</b><br><textarea class='editable' onchange='answers["+i+"]=this.value'>"+ String(ans).replace(/</g,"&lt;") +"</textarea>";
        ul && ul.appendChild(li);
      });
    }catch(_){}
  };

  function total(){ try{ return Array.isArray(window.questions) ? window.questions.length : null; }catch(_){ return null; } }
  function idx(){ try{ return (typeof window.currentQuestion==='number') ? (window.currentQuestion|0) : null; }catch(_){ return null; } }

  // Minimal last-question trigger: when on last index and user clicks the main validate button, show summary instead of advancing.
  document.addEventListener("DOMContentLoaded", function(){
    var btn = byId("validerBtn");
    if (!btn) return;
    var clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.addEventListener("click", function(ev){
      try{
        var t = total(), i = idx();
        // Save current text answer
        var ta = byId("answerInput");
        if (ta){
          if (!Array.isArray(window.answers)) window.answers = [];
          window.answers[i||0] = ta.value||"";
        }
        if (t!=null && i!=null && i >= t-1){
          ev.preventDefault(); ev.stopPropagation();
          window.showSummary();
          return false;
        }
      }catch(_){}
      // otherwise, let original default action bubble (no double increment)
    }, true);
  });

  // Wire PDF/Copy
  document.addEventListener("DOMContentLoaded", function(){
    var pdfBtn = byId("pdfBtn");
    if (pdfBtn){
      pdfBtn.onclick = function(){
        var txt = "Code: " + (window.userCode||"") + "\n";
        (window.questions||[]).forEach(function(q,i){ txt += (i+1)+". "+(q.text||'')+"\nRéponse: "+((window.answers&&window.answers[i])||'')+"\n\n"; });
        var w = window.open("", "_blank");
        if (w){ w.document.write("<pre>"+txt.replace(/</g,"&lt;")+"</pre>"); w.print(); }
      };
    }
    var copyBtn = byId("copyBtn");
    if (copyBtn){
      copyBtn.onclick = function(){
        var txt = "Code: " + (window.userCode||"") + "\n";
        (window.questions||[]).forEach(function(q,i){ txt += (i+1)+". "+(q.text||'')+": "+((window.answers&&window.answers[i])||'')+"\n"; });
        try{
          var blob = new Blob([txt], {type:"text/plain"});
          var link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = "Reponses_Questionnaire_"+(window.userCode||"")+".txt";
          link.click();
        }catch(_){}
      };
    }
  });
})();
</script>

</body>
</meta><style id="corrigerPatchCSS">#corrigerBtn{position:relative;z-index:99999;pointer-events:auto;}</style>
<script id="corrigerPatchJS">
(function(){
  if (window.__corrigerPatched) return; window.__corrigerPatched = true;

  function __bindCorriger(){
    var b = document.getElementById('corrigerBtn');
    if (!b) return;
    try{ b.type = 'button'; }catch(_){}
    // Inline onclick to survive aggressive capture/stopImmediatePropagation
    b.onclick = function(ev){
      try{ ev.preventDefault(); ev.stopPropagation(); }catch(_){}
      try{ if (window.recognition && window.listening){ recognition.abort&&recognition.abort(); recognition.stop&&recognition.stop(); window.listening=false; } }catch(_){}
      if (typeof window.goPrev === 'function'){ try{ window.goPrev(); return false; }catch(_){ } }
      // Fallback
      try{
        var idx = (typeof window.currentQuestion==='number')? window.currentQuestion : 0;
        if (idx > 0){
          window.currentQuestion = idx - 1;
          if (typeof window.showQuestion==='function'){ window.showQuestion(window.currentQuestion); }
        }
      }catch(_){}
      return false;
    };
  }

  // Initial bind
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', __bindCorriger); }
  else { __bindCorriger(); }

  // Rebind on any DOM change around the questionnaire area
  try{
    var mo = new MutationObserver(function(){ __bindCorriger(); });
    mo.observe(document.documentElement || document.body, { childList:true, subtree:true });
  }catch(_){}

  // As a final safety: capture-phase handler that triggers when clicking the button box even if overlaid
  function __capture(ev){
    var b=document.getElementById('corrigerBtn');
    if(!b) return;
    var t=ev.target, hit = (t && (t.id==='corrigerBtn' || (t.closest && t.closest('#corrigerBtn'))));
    if (!hit){
      try{
        var r=b.getBoundingClientRect();
        hit = (ev.clientX>=r.left && ev.clientX<=r.right && ev.clientY>=r.top && ev.clientY<=r.bottom);
      }catch(_){}
    }
    if (hit && typeof b.onclick === 'function'){
      try{ b.onclick(ev); }catch(_){}
    }
  }
  ['click','pointerdown','mousedown','touchstart'].forEach(function(evt){
    window.addEventListener(evt, __capture, true);
  });
})();
</script>

<!-- Q3/Q4 robust scale patch (ES5-only, non-invasive) -->
<style id="q34ForceCSS">
  body.q34-force #scoreContainer,
  body.q34-force #scoreBox,
  body.q34-force #score {
    display: block !important;
    visibility: visible !important;
  }
  body.q34-force #answerInput { display: none !important; }
</style>
<script>
(function(){
  function isQ34(i){ return i===2 || i===3; } // 0-based
  function bodyAdd(cls){
    var b=document.body||document.getElementsByTagName('body')[0];
    if(!b) return;
    var s=(b.className||'').split(/\s+/), found=false;
    for(var i=0;i<s.length;i++){ if(s[i]===cls){ found=true; break; } }
    if(!found){ b.className=(b.className?b.className+' ':'')+cls; }
  }
  function bodyRemove(cls){
    var b=document.body||document.getElementsByTagName('body')[0];
    if(!b) return;
    var s=(b.className||'').split(/\s+/), out=[], changed=false;
    for(var i=0;i<s.length;i++){ if(s[i]!==cls){ out.push(s[i]); } else { changed=true; } }
    if(changed){ b.className=out.join(' '); }
  }
  function forceScaleNow(){
    try{
      var idx = Number(window.currentQuestion);
      var sc = document.getElementById('scoreContainer') || document.getElementById('scoreBox') || document.getElementById('score');
      var txt = document.getElementById('answerInput');
      if (!sc) return;
      if (isQ34(idx)){
        bodyAdd('q34-force');
        // extra inline guard in case CSS classes toggle again
        sc.style.display='block'; sc.style.visibility='visible';
        if (txt){ txt.style.display='none'; }
        var si=document.getElementById('scoreInput');
        if (si && si.focus){ try{ si.focus(); si.select && si.select(); }catch(_){ } }
      } else {
        bodyRemove('q34-force');
        sc.style.display='none';
        if (txt){ txt.style.display=''; }
      }
    }catch(_){}
  }
  function scheduleReinforce(){
    // keep scale visible for a short window after showQuestion,
    // in case other scripts flip visibility back
    var n=0;
    function tick(){
      forceScaleNow();
      n++;
      if (n<15){ setTimeout(tick, 40); } // ~600ms total reinforcement
    }
    tick();
  }
  function tryAdvanceWith(v){
    try{
      var start = Number(window.currentQuestion);
      var advanced = false;
      if (typeof window.validateAnswer === 'function'){ try{ window.validateAnswer(v); }catch(_){ } }
      setTimeout(function(){
        try{
          var cur = Number(window.currentQuestion);
          if (cur !== start) return;
          // fallback to text flow
          var f=document.getElementById('answerInput');
          if (f){ try{ f.value=String(v); }catch(_){ } }
          var vb=document.getElementById('validerBtn') || document.getElementById('validateBtn');
          if (vb && vb.click){ try{ vb.click(); }catch(_){ } }
          else if (typeof window.validateAnswer === 'function'){ try{ window.validateAnswer(); }catch(_){ } }
        }catch(_){}
      }, 160);
    }catch(_){}
  }
  function bindEnterOk(){
    try{
      var si=document.getElementById('scoreInput');
      if (si && !si.__q34Enter){
        si.__q34Enter=true;
        si.addEventListener('keydown', function(e){
          try{
            if (e && e.key==='Enter'){
              if (e.preventDefault) e.preventDefault();
              if (e.stopPropagation) e.stopPropagation();
              var idx=Number(window.currentQuestion);
              if (!isQ34(idx)) return;
              var v=parseInt(si && si.value ? si.value : '',10);
              if (v>=1 && v<=5){ tryAdvanceWith(v); } else { try{ si.focus(); }catch(_){ } }
            }
          }catch(_){}
        }, false);
      }
      var ok=document.getElementById('validateScoreBtn') || document.getElementById('okBtn');
      if (ok && !ok.__q34Click){
        ok.__q34Click=true;
        ok.addEventListener('click', function(){
          try{
            var idx=Number(window.currentQuestion);
            if (!isQ34(idx)) return;
            var si2=document.getElementById('scoreInput');
            var v=parseInt(si2 && si2.value ? si2.value : '',10);
            if (v>=1 && v<=5){ tryAdvanceWith(v); } else { try{ si2 && si2.focus && si2.focus(); }catch(_){ } }
          }catch(_){}
        }, false);
      }
    }catch(_){}
  }
  function init(){
    forceScaleNow();
    bindEnterOk();
    scheduleReinforce();
    try{
      if (typeof window.showQuestion === 'function'){
        var _orig=window.showQuestion;
        window.showQuestion=function(){
          var r=_orig.apply(this, arguments);
          try{ bindEnterOk(); scheduleReinforce(); }catch(_){}
          return r;
        };
      }
    }catch(_){}
  }
  if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init, false); }
  else { init(); }
})();
</script>

<!-- Q3/Q4 enhancement: clear values & suppress error beeps after a valid submit -->
<script>
(function(){
  function isQ34(i){ return i===2 || i===3; }
  function byId(id){ return document.getElementById(id); }

  function clearErrors(){
    var ids = ['mainErrorMsg','scoreError','introErrorMsg','menuError','errorScale','errorLabel'];
    for (var i=0;i<ids.length;i++){
      var el = byId(ids[i]); if (el){ try{ el.textContent=''; el.innerHTML=''; }catch(_){ } }
    }
  }

  // Temporarily suppress common beep/error functions while we submit
  function suppressErrorsDuring(ms){
    var toRestore = [];
    function wrap(obj, name){
      try{
        if (obj && typeof obj[name] === 'function'){
          toRestore.push([obj, name, obj[name]]);
          obj[name] = function(){};
        }
      }catch(_){}
    }
    // Known candidates
    wrap(window, 'playBeep');
    wrap(window, 'beep');
    wrap(window, 'signalError');
    wrap(window, 'errorBeep');
    // Restore after ms
    setTimeout(function(){
      for (var i=0;i<toRestore.length;i++){
        try{ toRestore[i][0][toRestore[i][1]] = toRestore[i][2]; }catch(_){}
      }
    }, ms||400);
  }

  // Track question change to clear previous scale value & errors
  (function trackAdvance(){
    var last = (typeof window.currentQuestion==='number') ? window.currentQuestion : 0;
    setInterval(function(){
      try{
        var cur = (typeof window.currentQuestion==='number') ? window.currentQuestion : last;
        if (cur !== last){
          // If we just left Q3 or Q4, clean up lingering value/errors
          if (isQ34(last)){
            var si = byId('scoreInput'); if (si){ try{ si.value=''; }catch(_){ } }
            clearErrors();
            // Remove forcing class to avoid style bleed
            var b = document.body || document.getElementsByTagName('body')[0];
            if (b && b.className && b.className.indexOf('q34-force')!==-1){
              b.className = b.className.replace(/\bq34-force\b/g, '').replace(/\s{2,}/g,' ').trim();
            }
          }
          last = cur;
        }
      }catch(_){}
    }, 120);
  })();

  // Hook our existing submitter if present to add cleanup
  try{
    if (window.tryAdvanceWith && !window.tryAdvanceWith.__q34wrap){
      var _orig = window.tryAdvanceWith;
      window.tryAdvanceWith = function(v){
        try{ suppressErrorsDuring(800); clearErrors(); }catch(_){}
        try{ window.justCorrected=false; window.paused=false; window.isValidating=false; }catch(_){}
        var r;
        try{ r = _orig.call(this, v); }catch(e){ r = undefined; }
        // schedule cleanup once more
        setTimeout(function(){
          try{ clearErrors(); var si=byId('scoreInput'); if (si){ si.value=''; } }catch(_){}
        }, 220);
        return r;
      };
      window.tryAdvanceWith.__q34wrap = true;
    }
  }catch(_){}

  // Also bind OK button directly to cleanup when it succeeds
  (function bindOkCleanup(){
    var ok = byId('validateScoreBtn') || byId('okBtn');
    if (ok && !ok.__q34clean){
      ok.__q34clean = true;
      ok.addEventListener('click', function(){
        setTimeout(function(){ try{ clearErrors(); }catch(_){ } }, 220);
      }, false);
    }
  })();
})();
</script>

<!-- Q3/Q4: mute 'beep' when value 1–5 is valid -->
<script>
(function(){
  function isQ34(){ try{ return Number(window.currentQuestion)===2 || Number(window.currentQuestion)===3; }catch(_){ return false; } }
  function valIsValid(){
    try{
      var si = document.getElementById('scoreInput');
      var v = parseInt(si && si.value ? si.value : "", 10);
      return (v>=1 && v<=5);
    }catch(_){ return false; }
  }
  // Flag during a legitimate submit to mute beeps transiently
  function setSubmitting(flag){
    try{ window.__q34ValidSubmitting = !!flag; }catch(_){}
  }
  function shouldMute(){
    return isQ34() && (valIsValid() || window.__q34ValidSubmitting===true);
  }

  // Wrap common beep/error functions if they exist
  function wrapMute(obj, name){
    try{
      if (!obj || typeof obj[name] !== 'function') return;
      if (obj[name].__q34wrapped) return;
      var _orig = obj[name];
      obj[name] = function(){
        if (shouldMute()) return;
        return _orig.apply(this, arguments);
      };
      obj[name].__q34wrapped = true;
    }catch(_){}
  }
  wrapMute(window, 'playBeep');
  wrapMute(window, 'beep');
  wrapMute(window, 'signalError');
  wrapMute(window, 'errorBeep');

  // Also wrap a generic error label setter if present
  function wrapSetter(id){
    var el = document.getElementById(id);
    if (!el) return;
    var desc = Object.getOwnPropertyDescriptor(el.__proto__ || Object.getPrototypeOf(el), 'textContent');
    try{
      if (desc && desc.set && !el.__q34tcWrapped){
        var _set = desc.set;
        Object.defineProperty(el, 'textContent', {
          set: function(v){
            if (shouldMute()) v = '';
            return _set.call(this, v);
          }
        });
        el.__q34tcWrapped = true;
      }
    }catch(_){}
  }
  ['mainErrorMsg','scoreError','introErrorMsg','menuError','errorScale','errorLabel'].forEach(wrapSetter);

  // Ensure our submission path toggles the submitting flag
  function attachSubmitGuards(){
    var si = document.getElementById('scoreInput');
    var ok = document.getElementById('validateScoreBtn') || document.getElementById('okBtn');
    if (si && !si.__q34guardKD){
      si.__q34guardKD = true;
      si.addEventListener('keydown', function(e){
        if (e && e.key==='Enter'){
          setSubmitting(true);
          setTimeout(function(){ setSubmitting(false); }, 800);
        }
      }, false);
    }
    if (ok && !ok.__q34guardCL){
      ok.__q34guardCL = true;
      ok.addEventListener('click', function(){
        setSubmitting(true);
        setTimeout(function(){ setSubmitting(false); }, 800);
      }, false);
    }
  }

  // If our earlier submit helper exists, wrap it as well
  try{
    if (window.tryAdvanceWith && !window.tryAdvanceWith.__q34muteWrap){
      var _origTAW = window.tryAdvanceWith;
      window.tryAdvanceWith = function(v){
        setSubmitting(true);
        try{ return _origTAW.apply(this, arguments); }
        finally{ setTimeout(function(){ setSubmitting(false); }, 800); }
      };
      window.tryAdvanceWith.__q34muteWrap = true;
    }
  }catch(_){}

  function init(){ attachSubmitGuards(); }
  if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init, false); } else { init(); }
  try{
    if (typeof window.showQuestion==='function'){
      var _orig = window.showQuestion;
      window.showQuestion = function(){
        var r = _orig.apply(this, arguments);
        try{ attachSubmitGuards(); }catch(_){}
        return r;
      };
    }
  }catch(_){}
})();
</script>

<!-- Q3/Q4: Allow beep ONLY when value is NOT 1..5; prevent double-beeps -->
<script>
(function(){
  function isQ34(){
    try{ var i = Number(window.currentQuestion); return i===2 || i===3; }catch(_){ return false; }
  }
  function valIsValid(){
    try{
      var si = document.getElementById('scoreInput');
      var v  = parseInt(si && si.value ? si.value : "", 10);
      return (v>=1 && v<=5);
    }catch(_){ return false; }
  }
  function wrapBeep(obj, name){
    try{
      if (!obj || typeof obj[name] !== 'function') return;
      if (obj[name].__q34smartWrapped) return;
      var _orig = obj[name];
      var lastWhen = 0;
      obj[name] = function(){
        // On Q3/Q4: beep only if NOT 1..5
        if (isQ34()){
          if (valIsValid()){
            return; // suppress beep for valid value
          }else{
            // invalid value -> allow a single beep window
            var now = Date.now ? Date.now() : (+new Date());
            if (now - lastWhen < 250){ return; } // prevent double-beep
            lastWhen = now;
            try{ return _orig.apply(this, arguments); }catch(e){ return; }
          }
        } else {
          // Other questions: keep default, but prevent rapid double-beep
          var now2 = Date.now ? Date.now() : (+new Date());
          if (now2 - lastWhen < 250){ return; }
          lastWhen = now2;
          try{ return _orig.apply(this, arguments); }catch(e){ return; }
        }
      };
      obj[name].__q34smartWrapped = true;
    }catch(_){}
  }

  // Apply to common beep/error functions
  wrapBeep(window, 'playBeep');
  wrapBeep(window, 'beep');
  wrapBeep(window, 'signalError');
  wrapBeep(window, 'errorBeep');
})();
</script>

<!-- Q3/Q4: STRICT beep control — suppress ONLY for valid 1..5 submissions -->
<script>
(function(){
  function isQ34(){
    try{ var i = Number(window.currentQuestion); return i===2 || i===3; }catch(_){ return false; }
  }
  function isValidScore(n){
    return typeof n === 'number' && n >= 1 && n <= 5 && Math.floor(n) === n;
  }
  // Guard state
  window.__q34_beep_guard = window.__q34_beep_guard || { until: 0, lastValid: false };
  function now(){ return Date.now ? Date.now() : (+new Date()); }
  function armBeepGuard(valid){
    try{
      window.__q34_beep_guard.lastValid = !!valid;
      window.__q34_beep_guard.until = now() + 900; // ~0.9s window across submit/advance
    }catch(_){}
  }
  function guardActive(){ try{ return now() < window.__q34_beep_guard.until; }catch(_){ return false; } }
  function guardValid(){ try{ return !!window.__q34_beep_guard.lastValid; }catch(_){ return false; } }

  // Wrap beep-like functions so that:
  // - On Q3/Q4: if we are within guard window and submission was VALID (1..5), suppress the beep.
  // - Otherwise, allow it (including invalid entries).
  function wrapBeep(obj, name){
    try{
      if (!obj || typeof obj[name] !== 'function') return;
      if (obj[name].__q34strictWrapped) return;
      var _orig = obj[name];
      obj[name] = function(){
        if (isQ34() && guardActive() && guardValid()){
          return; // suppress beep only for a valid guarded submit
        }
        return _orig.apply(this, arguments);
      };
      obj[name].__q34strictWrapped = true;
    }catch(_){}
  }
  wrapBeep(window, 'playBeep');
  wrapBeep(window, 'beep');
  wrapBeep(window, 'signalError');
  wrapBeep(window, 'errorBeep');

  // Arm the guard exactly when the user submits a value with Enter/OK on Q3/Q4
  function attachSubmitArmer(){
    try{
      var si = document.getElementById('scoreInput');
      var ok = document.getElementById('validateScoreBtn') || document.getElementById('okBtn');
      if (si && !si.__q34_armKD){
        si.__q34_armKD = true;
        si.addEventListener('keydown', function(e){
          try{
            if (e && e.key === 'Enter' && isQ34()){
              var v = parseInt(si && si.value ? si.value : '', 10);
              armBeepGuard(isValidScore(v));
            }
          }catch(_){}
        }, false);
      }
      if (ok && !ok.__q34_armCL){
        ok.__q34_armCL = true;
        ok.addEventListener('click', function(){
          try{
            if (isQ34()){
              var si2 = document.getElementById('scoreInput');
              var v2 = parseInt(si2 && si2.value ? si2.value : '', 10);
              armBeepGuard(isValidScore(v2));
            }
          }catch(_){}
        }, false);
      }
    }catch(_){}
  }

  // Also arm on programmatic path if our helper exists
  try{
    if (window.tryAdvanceWith && !window.tryAdvanceWith.__q34_armWrap){
      var _origTAW = window.tryAdvanceWith;
      window.tryAdvanceWith = function(v){
        try{ if (isQ34()) armBeepGuard(isValidScore(parseInt(v,10))); }catch(_){}
        return _origTAW.apply(this, arguments);
      };
      window.tryAdvanceWith.__q34_armWrap = true;
    }
  }catch(_){}

  function init(){ attachSubmitArmer(); }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', init, false); } else { init(); }
  try{
    if (typeof window.showQuestion === 'function'){
      var _orig = window.showQuestion;
      window.showQuestion = function(){
        var r = _orig.apply(this, arguments);
        try{ attachSubmitArmer(); }catch(_){}
        return r;
      };
    }
  }catch(_){}
})();
</script>

<!-- Q3/Q4: HARD MUTE for valid 1–5 submissions (covers custom beep(), audio tags, and new Audio().play) -->
<script>
(function(){
  function isQ34(){ try{ var i = Number(window.currentQuestion); return i===2 || i===3; }catch(_){ return false; } }
  function isValidScore(){
    try{
      var si = document.getElementById('scoreInput');
      var v = parseInt(si && si.value ? si.value : '', 10);
      return (v>=1 && v<=5);
    }catch(_){ return false; }
  }
  var mute = { until: 0, activeForValid: false };
  function now(){ return Date.now ? Date.now() : (+new Date()); }
  function shouldMute(){
    return isQ34() && mute.activeForValid && now() < mute.until;
  }
  function armMute(ms){
    mute.activeForValid = true;
    mute.until = now() + (ms || 1200);
  }

  // Wrap named beep-like functions (playBeep, beep, signalError, errorBeep, etc.)
  function wrapBeepNames(){
    var names = ['playBeep','beep','signalError','errorBeep','warnBeep','ding','buzz'];
    for (var i=0;i<names.length;i++){
      (function(key){
        try{
          if (typeof window[key] === 'function' && !window[key].__q34HardMute){
            var _orig = window[key];
            window[key] = function(){
              if (shouldMute()) return;
              return _orig.apply(this, arguments);
            };
            window[key].__q34HardMute = true;
          }
        }catch(_){}
      })(names[i]);
    }
  }

  // Wrap any window functions that CONTAIN 'beep' in their name at runtime.
  function wrapDynamicBeepers(){
    try{
      for (var k in window){
        if (!Object.prototype.hasOwnProperty.call(window, k)) continue;
        if (typeof window[k] === 'function' && /beep/i.test(k) && !window[k].__q34HardMuteDyn){
          (function(key){
            var _orig = window[key];
            window[key] = function(){
              if (shouldMute()) return;
              return _orig.apply(this, arguments);
            };
            window[key].__q34HardMuteDyn = true;
          })(k);
        }
      }
    }catch(_){}
  }

  // Wrap audio playback at the DOM API level (covers <audio>.play() and new Audio().play())
  function wrapAudioPlay(){
    try{
      var H = window.HTMLMediaElement || window.HTMLAudioElement || null;
      if (!H || !H.prototype) return;
      if (H.prototype.play && !H.prototype.play.__q34HardMute){
        var _p = H.prototype.play;
        H.prototype.play = function(){
          if (shouldMute()){
            try{ this.pause && this.pause(); }catch(_){}
            try{ this.currentTime = 0; }catch(_){}
            // mimic a resolved promise if available
            if (window.Promise){ return Promise.resolve(); }
            return;
          }
          return _p.apply(this, arguments);
        };
        H.prototype.play.__q34HardMute = true;
      }
    }catch(_){}
  }

  // Arm muting exactly on submit with Enter/OK if value is valid 1..5
  function attachSubmitArmer(){
    var si = document.getElementById('scoreInput');
    var ok = document.getElementById('validateScoreBtn') || document.getElementById('okBtn');
    if (si && !si.__q34HardMuteKD){
      si.__q34HardMuteKD = true;
      si.addEventListener('keydown', function(e){
        if (e && e.key === 'Enter' && isQ34()){
          if (isValidScore()) armMute(1500);
        }
      }, false);
    }
    if (ok && !ok.__q34HardMuteCL){
      ok.__q34HardMuteCL = true;
      ok.addEventListener('click', function(){
        if (isQ34() && isValidScore()) armMute(1500);
      }, false);
    }
  }

  // Also hook our programmatic path if present
  try{
    if (window.tryAdvanceWith && !window.tryAdvanceWith.__q34HardMuteWrap){
      var _orig = window.tryAdvanceWith;
      window.tryAdvanceWith = function(v){
        try{
          var n = parseInt(v,10);
          if (isQ34() && n>=1 && n<=5) armMute(1500);
        }catch(_){}
        return _orig.apply(this, arguments);
      };
      window.tryAdvanceWith.__q34HardMuteWrap = true;
    }
  }catch(_){}

  function init(){
    wrapBeepNames();
    wrapDynamicBeepers();
    wrapAudioPlay();
    attachSubmitArmer();
    // re-check after question changes
    try{
      if (typeof window.showQuestion === 'function'){
        var _orig = window.showQuestion;
        window.showQuestion = function(){
          var r = _orig.apply(this, arguments);
          try{
            wrapBeepNames();
            wrapDynamicBeepers();
            wrapAudioPlay();
            attachSubmitArmer();
          }catch(_){}
          return r;
        };
      }
    }catch(_){}
  }

  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', init, false); }
  else { init(); }
})();
</script>

<!-- Q3/Q4: first-visit warmup to avoid spurious beep; only once per question -->
<script>
(function(){
  var q34Warm = { seen: {} };
  function isQ34(i){ return i===2 || i===3; }
  function now(){ return Date.now ? Date.now() : (+new Date()); }
  function armValidMute(ms){
    try{
      // Reuse the v6 guard if present
      if (!window.__q34_beep_guard){ window.__q34_beep_guard = { until: 0, lastValid: true }; }
      window.__q34_beep_guard.lastValid = true;
      window.__q34_beep_guard.until = now() + (ms||1200);
    }catch(_){}
  }
  function onEnterQ(index){
    try{
      if (!isQ34(index)) return;
      if (!q34Warm.seen[index]){
        q34Warm.seen[index] = true;
        // On first time landing on Q3 or Q4 during this session,
        // we arm a short mute window so any initial UI checks won't beep.
        armValidMute(1400);
        // also clear any existing error labels just in case
        var ids = ['mainErrorMsg','scoreError','errorScale','errorLabel'];
        for (var i=0;i<ids.length;i++){
          var el = document.getElementById(ids[i]);
          if (el){ try{ el.textContent=''; el.innerHTML=''; }catch(_){}
          }
        }
      }
    }catch(_){}
  }
  function hookShow(){
    try{
      if (typeof window.showQuestion === 'function' && !window.showQuestion.__q34WarmWrapped){
        var _orig = window.showQuestion;
        window.showQuestion = function(idx){
          var r = _orig.apply(this, arguments);
          try{
            var i = (typeof idx === 'number') ? idx : (typeof window.currentQuestion==='number' ? window.currentQuestion : 0);
            onEnterQ(Number(i));
          }catch(_){}
          return r;
        };
        window.showQuestion.__q34WarmWrapped = true;
      } else {
        // If no showQuestion, attempt once at load using currentQuestion
        var i2 = Number(window.currentQuestion||0);
        onEnterQ(i2);
      }
    }catch(_){}
  }
  if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', hookShow, false); }
  else { hookShow(); }
})();
</script>

<!-- Q3/Q4: FINAL no-beep-on-valid — capture Enter/OK at top level, stop propagation, hard-mute during our own submit -->
<script>
(function(){
  function isQ34(){ try{ var i = Number(window.currentQuestion); return i===2 || i===3; }catch(_){ return false; } }
  function val(){
    try{ var si=document.getElementById('scoreInput'); return parseInt(si && si.value ? si.value : '', 10); }catch(_){ return NaN; }
  }
  function isValid(n){ return n>=1 && n<=5 && Math.floor(n)===n; }

  // Hard mute any beeps/audio for a short window
  var __muteUntil = 0;
  function now(){ return Date.now ? Date.now() : (+new Date()); }
  function armMute(ms){ __muteUntil = now() + (ms||1500); }
  function shouldMute(){ return now() < __muteUntil; }

  // Wrap beep-like functions and audio play once
  (function wrapOnce(){
    var names=['playBeep','beep','signalError','errorBeep','warnBeep','ding','buzz'];
    for (var i=0;i<names.length;i++){
      (function(k){
        try{
          if (typeof window[k]==='function' && !window[k].__q34NoBeep){
            var _o = window[k];
            window[k]=function(){ if (shouldMute()) return; return _o.apply(this, arguments); };
            window[k].__q34NoBeep = true;
          }
        }catch(_){}
      })(names[i]);
    }
    try{
      var H = window.HTMLMediaElement || window.HTMLAudioElement;
      if (H && H.prototype && H.prototype.play && !H.prototype.play.__q34NoBeep){
        var _p = H.prototype.play;
        H.prototype.play = function(){
          if (shouldMute()){
            try{ this.pause && this.pause(); this.currentTime=0; }catch(_){}
            if (window.Promise){ return Promise.resolve(); }
            return;
          }
          return _p.apply(this, arguments);
        };
        H.prototype.play.__q34NoBeep = true;
      }
    }catch(_){}
  })();

  function submitValue(n){
    try{
      armMute(1500); // silence anything during our controlled submit
      // Prefer validateAnswer(n); fall back to text flow
      var start = Number(window.currentQuestion);
      if (typeof window.validateAnswer==='function'){ try{ window.validateAnswer(n); }catch(_){ } }
      setTimeout(function(){
        try{
          var cur = Number(window.currentQuestion);
          if (cur !== start) return; // advanced OK
          var f=document.getElementById('answerInput'); if (f){ try{ f.value=String(n); }catch(_){ } }
          var vb=document.getElementById('validerBtn')||document.getElementById('validateBtn');
          if (vb && vb.click){ try{ vb.click(); }catch(_){ } }
        }catch(_){}
      }, 80);
    }catch(_){}
  }

  // GLOBAL CAPTURE: intercept Enter on scoreInput before any other handler
  function onKeydownCapture(e){
    try{
      if (!isQ34()) return;
      if (!e || e.key!=='Enter') return;
      var t = e.target || e.srcElement;
      if (!t || t.id!=='scoreInput') return;
      var n = val();
      if (isValid(n)){
        // Eat the event fully to prevent any native/error beep path
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
        if (e.preventDefault) e.preventDefault();
        e.cancelBubble = true;
        e.returnValue = false;
        submitValue(n);
      }
    }catch(_){}
  }
  // GLOBAL CAPTURE: intercept click on OK
  function onClickCapture(e){
    try{
      if (!isQ34()) return;
      var t = e.target || e.srcElement;
      if (!t) return;
      var id = t.id || '';
      if (id==='validateScoreBtn' || id==='okBtn'){
        var n = val();
        if (isValid(n)){
          if (e.stopImmediatePropagation) e.stopImmediatePropagation();
          if (e.preventDefault) e.preventDefault();
          e.cancelBubble = true;
          e.returnValue = false;
          submitValue(n);
        }
      }
    }catch(_){}
  }

  // Attach capturing listeners once
  function attachCaptures(){
    try{
      if (!window.__q34NoBeepCapKD){
        window.addEventListener('keydown', onKeydownCapture, true); // capture
        window.__q34NoBeepCapKD = true;
      }
      if (!window.__q34NoBeepCapCL){
        window.addEventListener('click', onClickCapture, true); // capture
        window.__q34NoBeepCapCL = true;
      }
    }catch(_){}
  }

  // Also ensure we attach after each showQuestion
  function hookShow(){
    try{
      if (typeof window.showQuestion==='function' && !window.showQuestion.__q34NoBeepWrap){
        var _orig = window.showQuestion;
        window.showQuestion = function(){
          var r = _orig.apply(this, arguments);
          try{ attachCaptures(); }catch(_){}
          return r;
        };
        window.showQuestion.__q34NoBeepWrap = true;
      }
    }catch(_){}
  }

  if (document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', function(){ attachCaptures(); hookShow(); }, false);
  } else {
    attachCaptures(); hookShow();
  }
})();
</script>

<!-- Q3/Q4: after invalid submit (e.g., 7 or letters), LET the beep happen then clear the field -->
<script>
(function(){
  function isQ34(){
    try{ var i = Number(window.currentQuestion); return i===2 || i===3; }catch(_){ return false; }
  }
  function isValid(n){ return n>=1 && n<=5 && Math.floor(n)===n; }
  function currentValue(){
    try{
      var si = document.getElementById('scoreInput');
      return parseInt(si && si.value ? si.value : '', 10);
    }catch(_){ return NaN; }
  }
  function clearAndRefocusSoon(delay){
    setTimeout(function(){
      try{
        var si = document.getElementById('scoreInput');
        if (si){ si.value=''; si.focus && si.focus(); }
      }catch(_){}
    }, delay || 60);
  }

  function onKeydownBubble(e){
    try{
      if (!isQ34()) return;
      if (!e || e.key !== 'Enter') return;
      var t = e.target || e.srcElement;
      if (!t || t.id !== 'scoreInput') return;
      var v = currentValue();
      if (!isValid(v)){
        // Let the beep happen; then clear
        clearAndRefocusSoon(80);
      }
    }catch(_){}
  }
  function onClickBubble(e){
    try{
      if (!isQ34()) return;
      var t = e.target || e.srcElement;
      if (!t) return;
      var id = t.id || '';
      if (id === 'validateScoreBtn' || id === 'okBtn'){
        var v = currentValue();
        if (!isValid(v)){
          clearAndRefocusSoon(80);
        }
      }
    }catch(_){}
  }

  // Attach in bubbling phase so beep from original handler can fire first
  function attachBubblers(){
    if (!window.__q34ClearBubKD){
      window.addEventListener('keydown', onKeydownBubble, false);
      window.__q34ClearBubKD = true;
    }
    if (!window.__q34ClearBubCL){
      window.addEventListener('click', onClickBubble, false);
      window.__q34ClearBubCL = true;
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', attachBubblers, false);
  } else {
    attachBubblers();
  }
  try{
    if (typeof window.showQuestion === 'function' && !window.showQuestion.__q34ClearWrap){
      var _orig = window.showQuestion;
      window.showQuestion = function(){
        var r = _orig.apply(this, arguments);
        try{ attachBubblers(); }catch(_){}
        return r;
      };
      window.showQuestion.__q34ClearWrap = true;
    }
  }catch(_){}
})();
</script>

<!-- Q3/Q4 v10: ensure invalid entries are cleared even if other handlers stop propagation -->
<script>
(function(){
  function isQ34(){
    try{ var i = Number(window.currentQuestion); return i===2 || i===3; }catch(_){ return false; }
  }
  function isValid(n){ return n>=1 && n<=5 && Math.floor(n)===n; }
  function currentValue(){
    try{
      var si = document.getElementById('scoreInput');
      if (!si) return NaN;
      var raw = (si.value || '').trim();
      var n = parseInt(raw, 10);
      if (String(n) !== raw && !/^([1-5])$/.test(raw)) return NaN; // non-digits stay invalid
      return n;
    }catch(_){ return NaN; }
  }
  function clearAndRefocusSoon(delay){
    setTimeout(function(){
      try{
        var si = document.getElementById('scoreInput');
        if (si){ si.value=''; si.focus && si.focus(); }
      }catch(_){}
    }, delay || 60);
  }

  // CAPTURE listeners: they always run, even if later handlers stop propagation.
  function onKeydownCapture(e){
    try{
      if (!isQ34()) return;
      if (!e || e.key !== 'Enter') return;
      var t = e.target || e.srcElement;
      if (!t || t.id !== 'scoreInput') return;
      var v = currentValue();
      if (!isValid(v)){
        // Do NOT prevent default nor stop propagation; just schedule clear after beep
        clearAndRefocusSoon(90);
      }
    }catch(_){}
  }
  function onClickCapture(e){
    try{
      if (!isQ34()) return;
      var t = e.target || e.srcElement;
      if (!t) return;
      var id = t.id || '';
      if (id === 'validateScoreBtn' || id === 'okBtn'){
        var v = currentValue();
        if (!isValid(v)){
          clearAndRefocusSoon(90);
        }
      }
    }catch(_){}
  }

  function attachCaptureClears(){
    if (!window.__q34CapClrKD){
      window.addEventListener('keydown', onKeydownCapture, true); // capture
      window.__q34CapClrKD = true;
    }
    if (!window.__q34CapClrCL){
      window.addEventListener('click', onClickCapture, true); // capture
      window.__q34CapClrCL = true;
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', attachCaptureClears, false);
  } else {
    attachCaptureClears();
  }
  try{
    if (typeof window.showQuestion === 'function' && !window.showQuestion.__q34CapClrWrap){
      var _orig = window.showQuestion;
      window.showQuestion = function(){
        var r = _orig.apply(this, arguments);
        try{ attachCaptureClears(); }catch(_){}
        return r;
      };
      window.showQuestion.__q34CapClrWrap = true;
    }
  }catch(_){}
})();
</script>



<!-- === DSM-style scale patch (ES5) for Q5,Q6,Q7 === -->
<script type="text/javascript">
(function(){
  window.SCALE_LABELS = window.SCALE_LABELS || {};
  if (!window.SCALE_LABELS.sv) {
    window.SCALE_LABELS.sv = {
      numeric : ["aldrig","ibland","ofta","mycket ofta","alltid"],
      helpPrefix: "Välj 1–5"
    };
  }
  window.NOTABLES = window.NOTABLES || [];
  var ADD = [4,5,6]; for (var i=0;i<ADD.length;i++){ var v=Number(ADD[i]); var f=false; for (var j=0;j<window.NOTABLES.length;j++){ if (window.NOTABLES[j]===v){f=true;break;} } if(!f) window.NOTABLES.push(v); }
  function isNotable(idx){ idx=Number(idx); var L=window.NOTABLES||[]; for (var k=0;k<L.length;k++){ if(L[k]===idx) return true; } return false; }
  try{ window.isQ34=isNotable; }catch(_){}
  try{ if (Object.prototype.toString.call(window.questions)==='[object Array]'){ var L2=window.NOTABLES||[]; for (var m=0;m<L2.length;m++){ var qidx=L2[m]; if (window.questions[qidx]) window.questions[qidx].type='scale'; } } }catch(_){}
  function apply(qi){ try{ var L=window.SCALE_LABELS && window.SCALE_LABELS.sv; var lab=document.getElementById('scoreLabel'); if(lab&&L){ lab.style.color='red'; lab.style.fontWeight='bold'; lab.textContent=L.helpPrefix+': 1='+L.numeric[0]+', 2='+L.numeric[1]+', 3='+L.numeric[2]+', 4='+L.numeric[3]+', 5='+L.numeric[4]; } var si=document.getElementById('scoreInput'); if(si){ si.setAttribute('min','1'); si.setAttribute('max','5'); si.setAttribute('step','1'); } }catch(_){ } }
  if (typeof window.applyScaleLabels!=='function') window.applyScaleLabels = apply;
  function ensure(){ try{ var idx=Number(window.currentQuestion||0); var sc=document.getElementById('scoreContainer')||document.getElementById('scoreBox')||document.getElementById('score'); var txt=document.getElementById('answerInput'); var si=document.getElementById('scoreInput'); if(!sc) return; if(isNotable(idx)){ sc.style.display='block'; sc.style.visibility='visible'; if(txt){ txt.style.display='none'; } window.applyScaleLabels(idx); if(si&&si.focus){ try{ si.focus(); si.select&&si.select(); }catch(_){ } } } else { sc.style.display='none'; if(txt){ txt.style.display=''; } } }catch(_){ } }
  function reinf(){ var n=0;(function t(){ ensure(); if(++n<16) setTimeout(t,40); })(); }
  function init(){ ensure(); reinf(); try{ if(typeof window.showQuestion==='function' && !window.showQuestion.__dsm){ var _o=window.showQuestion; window.showQuestion=function(){ var r=_o.apply(this, arguments); try{ reinf(); }catch(_){ } return r; }; window.showQuestion.__dsm=true; } }catch(_){ } }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init, false); } else { init(); }
})();
</script>





<!-- Robust submit for NOTABLES (ES5): no beep on valid 1–5, advance; beep+clear on invalid -->
<script type="text/javascript">
(function(){
  function isNotable(idx){
    try{
      idx = Number(idx);
      var L = window.NOTABLES || [];
      for (var i=0;i<L.length;i++){ if (L[i]===idx) return true; }
    }catch(_){}
    return false;
  }
  function cur(){ return Number(window.currentQuestion||0); }
  function getSI(){ return document.getElementById('scoreInput'); }
  function getVB(){ return document.getElementById('validerBtn') || document.getElementById('validateBtn'); }
  function getTXT(){ return document.getElementById('answerInput'); }
  function isValid(n){ return typeof n==='number' && n>=1 && n<=5 && Math.floor(n)===n; }
  function readVal(){
    var si=getSI(); if (!si) return NaN;
    var raw=(si.value||'').trim();
    var n=parseInt(raw,10);
    if (String(n)!==raw && !/^([1-5])$/.test(raw)) return NaN;
    return n;
  }
  function clearFocusSoon(delay){
    setTimeout(function(){ try{ var si=getSI(); if (si){ si.value=''; si.focus && si.focus(); } }catch(_){ } }, delay||80);
  }
  var muteUntil=0; function now(){ return Date.now?Date.now():(+new Date()); }
  function armMute(ms){ muteUntil = now() + (ms||1200); }
  function shouldMute(){ return now() < muteUntil; }
  (function wrapBeep(){
    var names=['playBeep','beep','signalError','errorBeep','warnBeep','ding','buzz'];
    for (var i=0;i<names.length;i++){
      (function(k){
        try{
          if (typeof window[k]==='function' && !window[k].__nwrap){
            var _o=window[k];
            window[k]=function(){ if (shouldMute()) return; return _o.apply(this, arguments); };
            window[k].__nwrap=true;
          }
        }catch(_){}
      })(names[i]);
    }
    try{
      var H=window.HTMLMediaElement||window.HTMLAudioElement;
      if (H && H.prototype && H.prototype.play && !H.prototype.play.__nwrap){
        var _p=H.prototype.play;
        H.prototype.play=function(){
          if (shouldMute()){ try{ this.pause&&this.pause(); this.currentTime=0; }catch(_){ } if (window.Promise){ return Promise.resolve(); } return; }
          return _p.apply(this, arguments);
        };
        H.prototype.play.__nwrap=true;
      }
    }catch(_){}
  })();

  function submitValid(n){
    try{
      armMute(1200);
      var start = cur();
      if (typeof window.validateAnswer==='function'){ try{ window.validateAnswer(n); }catch(_){ } }
      setTimeout(function(){
        try{
          if (cur()!==start) return;
          var f=getTXT(); if (f){ try{ f.value=String(n); }catch(_){ } }
          var vb=getVB(); if (vb && vb.click){ try{ vb.click(); }catch(_){ } }
        }catch(_){}
      }, 80);
    }catch(_){}
  }

  function onKeydownCapture(e){
    try{
      if (!e || e.key!=='Enter') return;
      var t=e.target||e.srcElement; if (!t || t.id!=='scoreInput') return;
      var i=cur(); if (!isNotable(i)) return;
      var v=readVal();
      if (isValid(v)){
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
        if (e.preventDefault) e.preventDefault();
        e.cancelBubble=true; e.returnValue=false;
        submitValid(v);
      } else { clearFocusSoon(90); }
    }catch(_){}
  }
  function onClickCapture(e){
    try{
      var t=e.target||e.srcElement; if (!t) return;
      var id=t.id||''; if (id!=='validateScoreBtn' && id!=='okBtn') return;
      var i=cur(); if (!isNotable(i)) return;
      var v=readVal();
      if (isValid(v)){
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
        if (e.preventDefault) e.preventDefault();
        e.cancelBubble=true; e.returnValue=false;
        submitValid(v);
      } else { clearFocusSoon(90); }
    }catch(_){}
  }
  function attach(){
    if (!window.__nbCapKD){ window.addEventListener('keydown', onKeydownCapture, true); window.__nbCapKD=true; }
    if (!window.__nbCapCL){ window.addEventListener('click', onClickCapture, true); window.__nbCapCL=true; }
  }
  attach();
  try{
    if (typeof window.showQuestion==='function' && !window.showQuestion.__nbWrap){
      var _orig=window.showQuestion;
      window.showQuestion=function(){
        var r=_orig.apply(this, arguments);
        try{ attach(); }catch(_){}
        return r;
      };
      window.showQuestion.__nbWrap=true;
    }
  }catch(_){}
})();
</script>





<!-- Anti-flicker for notable questions (ES5): stable CSS class + double-RAF -->
<style id="nbStableCSS">
  /* When a notable question is active, keep the scale visible and the text box hidden without toggling inline styles */
  body.nb-on #scoreContainer,
  body.nb-on #scoreBox,
  body.nb-on #score { display: block !important; visibility: visible !important; }
  body.nb-on #answerInput { display: none !important; }
</style>
<script type="text/javascript">
(function(){
  function cur(){ return Number(window.currentQuestion||0); }
  function hasClass(el, cls){
    if (!el) return false;
    var s = (el.className||"").split(/\s+/);
    for (var i=0;i<s.length;i++){ if (s[i]===cls) return true; }
    return false;
  }
  function addClass(el, cls){
    if (!el) return;
    if (!hasClass(el, cls)){ el.className = (el.className? el.className+" " : "") + cls; }
  }
  function removeClass(el, cls){
    if (!el) return;
    var parts = (el.className||"").split(/\s+/), out=[], changed=false;
    for (var i=0;i<parts.length;i++){ if (parts[i]!==cls && parts[i]!=="") out.push(parts[i]); else changed=true; }
    if (changed) el.className = out.join(" ");
  }
  function isNotable(idx){
    try{
      idx = Number(idx);
      var L = window.NOTABLES || [];
      for (var i=0;i<L.length;i++){ if (L[i]===idx) return true; }
    }catch(_){}
    return false;
  }

  // Polyfilled requestAnimationFrame (ES5-safe)
  var raf = window.requestAnimationFrame || function(cb){ return setTimeout(cb, 16); };

  function applyStable(){
    try{
      var b = document.body || document.getElementsByTagName("body")[0];
      if (!b) return;
      var active = isNotable(cur());
      if (active){
        if (!hasClass(b, "nb-on")){
          addClass(b, "nb-on");
        }
        // Defer focus/labels after layout settles to avoid visible toggles
        raf(function(){ raf(function(){
          try{
            if (typeof window.applyScaleLabels === "function"){ window.applyScaleLabels(cur()); }
            var si = document.getElementById("scoreInput");
            if (si){
              try{ si.setAttribute("min","1"); si.setAttribute("max","5"); si.setAttribute("step","1"); }catch(_){}
              try{ si.focus(); si.select && si.select(); }catch(_){}
            }
          }catch(_){}
        }); });
      } else {
        if (hasClass(b, "nb-on")){
          removeClass(b, "nb-on");
        }
      }
    }catch(_){}
  }

  function init(){
    applyStable();
    try{
      if (typeof window.showQuestion === "function" && !window.showQuestion.__nbStableWrap){
        var _orig = window.showQuestion;
        window.showQuestion = function(){
          var r = _orig.apply(this, arguments);
          try{ applyStable(); }catch(_){}
          return r;
        };
        window.showQuestion.__nbStableWrap = true;
      }
    }catch(_){}
  }

  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", init, false);
  } else {
    init();
  }
})();
</script>





<!-- Add many NOTABLE questions (ES5, 0-based indices) -->
<script type="text/javascript">
(function(){
  // Questions given by user (1-based): 12,16,17,18,19,20,23,24,25,26,27,28,29,30,36,42,43,46
  // Converted to indices (0-based):
  var ADD = [11,15,16,17,18,19,22,23,24,25,26,27,28,29,35,41,42,45];

  // Merge into existing NOTABLES
  window.NOTABLES = window.NOTABLES || [];
  for (var i=0;i<ADD.length;i++){
    var v = Number(ADD[i]);
    if (window.NOTABLES.indexOf(v) === -1) window.NOTABLES.push(v);
  }

  // Mark bank entries as "scale" if available
  try{
    if (Object.prototype.toString.call(window.questions) === "[object Array]"){
      for (var j=0;j<window.NOTABLES.length;j++){
        var idx = window.NOTABLES[j];
        if (window.questions[idx]) { window.questions[idx].type = "scale"; }
      }
    }
  }catch(_){}
})();
</script>





<!-- FINAL OVERRIDE: make Q12 the first notable and remove notable status from Q3–Q7 -->
<script type="text/javascript">
(function(){
  // Desired notables (0-based): Q12=11, 16=15, 17=16, 18=17, 19=18, 20=19, 23=22, 24=23, 25=24,
  // 26=25, 27=26, 28=27, 29=28, 30=29, 36=35, 42=41, 43=42, 46=45
  var FINAL = [11,15,16,17,18,19,22,23,24,25,26,27,28,29,35,41,42,45];
  var TO_REMOVE = [2,3,4,5,6]; // Q3–Q7

  function arrayHas(arr, v){
    for (var i=0;i<arr.length;i++){ if (arr[i]===v) return true; }
    return false;
  }

  function applyFinal(){
    // 1) Force window.NOTABLES to the final list
    window.NOTABLES = FINAL.slice();

    // 2) Update question bank types when available
    try {
      if (Object.prototype.toString.call(window.questions) === "[object Array]") {
        // Explicitly clear Q3–Q7
        for (var r=0; r<TO_REMOVE.length; r++){
          var idxR = TO_REMOVE[r];
          if (window.questions[idxR]) { try { window.questions[idxR].type = "text"; } catch(_){ } }
        }
        // Mark all FINAL as scale
        for (var j=0; j<FINAL.length; j++){
          var idx = FINAL[j];
          if (window.questions[idx]) { try { window.questions[idx].type = "scale"; } catch(_){ } }
        }
      }
    } catch (e) {}

    // 3) If currently positioned on a removed question, hide scale / show text immediately
    try {
      var cq = Number(window.currentQuestion || 0);
      var isRemoved = arrayHas(TO_REMOVE, cq) || !arrayHas(FINAL, cq);
      if (isRemoved) {
        var b = document.body || document.getElementsByTagName("body")[0];
        if (b && b.className) {
          // remove nb-on class if present
          var parts = b.className.split(/\s+/), out=[], changed=false;
          for (var p=0;p<parts.length;p++){ if (parts[p] !== "nb-on") out.push(parts[p]); else changed=true; }
          if (changed) b.className = out.join(" ");
        }
        var sc  = document.getElementById("scoreContainer") || document.getElementById("scoreBox") || document.getElementById("score");
        var txt = document.getElementById("answerInput");
        if (sc) { try { sc.style.display = "none"; } catch(_){ } }
        if (txt) { try { txt.style.display = ""; txt.focus && txt.focus(); } catch(_){ } }
      }
    } catch(_){}
  }

  // Apply late so it overrides earlier patches
  if (document.readyState === "complete"){
    setTimeout(applyFinal, 0);
  } else {
    window.addEventListener("load", function(){ setTimeout(applyFinal, 0); }, false);
  }

  // Re-assert after each navigation to keep consistency
  try {
    if (typeof window.showQuestion === "function" && !window.showQuestion.__finalNotablesFix){
      var _orig = window.showQuestion;
      window.showQuestion = function(){
        var r = _orig.apply(this, arguments);
        try { applyFinal(); } catch(_){}
        return r;
      };
      window.showQuestion.__finalNotablesFix = true;
    }
  } catch(_){}
})();
</script>





<!-- HARD DISABLE SCALE on Q3–Q7 regardless of earlier patches -->
<style id="hardDisableQ3toQ7">
  /* Force text mode for Q3..Q7 (indices 2..6), even if 'nb-on' is present */
  body[data-q="2"] #scoreContainer,
  body[data-q="3"] #scoreContainer,
  body[data-q="4"] #scoreContainer,
  body[data-q="5"] #scoreContainer,
  body[data-q="6"] #scoreContainer,
  body[data-q="2"] #scoreBox,
  body[data-q="3"] #scoreBox,
  body[data-q="4"] #scoreBox,
  body[data-q="5"] #scoreBox,
  body[data-q="6"] #scoreBox,
  body[data-q="2"] #score,
  body[data-q="3"] #score,
  body[data-q="4"] #score,
  body[data-q="5"] #score,
  body[data-q="6"] #score {
    display: none !important;
    visibility: hidden !important;
  }
  body[data-q="2"] #answerInput,
  body[data-q="3"] #answerInput,
  body[data-q="4"] #answerInput,
  body[data-q="5"] #answerInput,
  body[data-q="6"] #answerInput {
    display: block !important;
    visibility: visible !important;
  }
</style>
<script type="text/javascript">
(function(){
  // Final NOTABLES list (0-based):
  var FINAL = [11,15,16,17,18,19,22,23,24,25,26,27,28,29,35,41,42,45];
  var BLOCK = {2:true,3:true,4:true,5:true,6:true}; // Q3..Q7

  // Enforce predicate + list
  window.NOTABLES = FINAL.slice();
  function isFinalNotable(i){
    i = Number(i);
    for (var k=0;k<FINAL.length;k++){ if (FINAL[k] === i) return true; }
    return false;
  }
  try { window.isQ34 = isFinalNotable; } catch(_){}

  // Update body[data-q] continuously to let CSS defeat earlier JS toggles
  function setBodyQ(idx){
    var b = document.body || document.getElementsByTagName('body')[0];
    if (!b) return;
    try { b.setAttribute('data-q', String(idx)); } catch(_){}
    // If blocked, also ensure class nb-on is removed
    if (BLOCK[idx]){
      var cls = (b.className||"").split(/\s+/), out=[], changed=false;
      for (var i=0;i<cls.length;i++){ if (cls[i] !== 'nb-on') out.push(cls[i]); else changed=true; }
      if (changed){ b.className = out.join(' '); }
    }
  }
  function tickQ(){
    var idx = Number(window.currentQuestion || 0);
    setBodyQ(idx);
  }
  // Keep asserting
  setInterval(tickQ, 60);

  // Also hook showQuestion to assert immediately on navigation
  try{
    if (typeof window.showQuestion === 'function' && !window.showQuestion.__hardQ37){
      var _orig = window.showQuestion;
      window.showQuestion = function(){
        var r = _orig.apply(this, arguments);
        try{ tickQ(); }catch(_){}
        return r;
      };
      window.showQuestion.__hardQ37 = true;
    }
  }catch(_){}

  // If a question bank exists, make sure types align
  try{
    if (Object.prototype.toString.call(window.questions) === "[object Array]"){
      for (var i=0;i<window.questions.length;i++){
        if (BLOCK[i]) { try{ window.questions[i].type = "text"; }catch(_){ } }
      }
      for (var j=0;j<FINAL.length;j++){
        var t = FINAL[j];
        if (window.questions[t]) { try{ window.questions[t].type = "scale"; }catch(_){ } }
      }
    }
  }catch(_){}
})();
</script>





<!-- Clear scale value when moving between consecutive notable questions (ES5) -->
<script type="text/javascript">
(function(){
  function isNotable(i){
    i = Number(i);
    var L = window.NOTABLES || [];
    for (var k=0;k<L.length;k++){ if (L[k] === i) return true; }
    return false;
  }
  function cur(){ return Number(window.currentQuestion || 0); }
  function clearScaleField(){
    try{
      var si = document.getElementById("scoreInput");
      if (si){ si.value = ""; }
      // also clear common error labels
      var ids = ["scoreError","errorScale","mainErrorMsg","errorLabel"];
      for (var i=0;i<ids.length;i++){
        var el = document.getElementById(ids[i]);
        if (el){ try{ el.textContent = ""; el.innerHTML = ""; }catch(_){ } }
      }
    }catch(_){}
  }

  // Track question changes; when entering a notable, clear the previous scale value
  (function track(){
    var last = cur();
    setInterval(function(){
      try{
        var c = cur();
        if (c !== last){
          // If moving into a notable (e.g., Q16→Q17), clear the field so old number doesn't persist
          if (isNotable(c)){ clearScaleField(); }
          last = c;
        }
      }catch(_){}
    }, 80);
  })();

  // Also clear immediately after each showQuestion call
  try{
    if (typeof window.showQuestion === "function" && !window.showQuestion.__clearOnNotableEnter){
      var _orig = window.showQuestion;
      window.showQuestion = function(){
        var r = _orig.apply(this, arguments);
        try{ if (isNotable(cur())) clearScaleField(); }catch(_){}
        return r;
      };
      window.showQuestion.__clearOnNotableEnter = true;
    }
  }catch(_){}
})();
</script>





<!-- Strengthen submit on notables: ensure '1'..'5' advance (no skip logic at all) -->
<script type="text/javascript">
(function(){
  function isNotable(i){
    i = Number(i);
    var L = window.NOTABLES || [];
    for (var k=0;k<L.length;k++){ if (L[k] === i) return true; }
    return false;
  }
  function cur(){ return Number(window.currentQuestion || 0); }
  function getSI(){ return document.getElementById('scoreInput'); }
  function getTXT(){ return document.getElementById('answerInput'); }
  function getNextBtn(){
    return document.getElementById('nextBtn') || document.getElementById('continueBtn') ||
           document.getElementById('validerBtn') || document.getElementById('validateBtn');
  }
  function isValid(n){ return typeof n==='number' && n>=1 && n<=5 && Math.floor(n)===n; }
  function readVal(){
    var si=getSI(); if (!si) return NaN;
    var raw=(si.value||'').trim();
    var n=parseInt(raw,10);
    if (String(n)!==raw && !/^([1-5])$/.test(raw)) return NaN;
    return n;
  }

  // Advance helpers (cover section changes)
  function advanceFlow(n, startIdx){
    // Try validateAnswer(n) first
    try{ if (typeof window.validateAnswer==='function'){ window.validateAnswer(n); } }catch(_){}
    // Reinforce: click next, then goNext/nextQuestion, then showQuestion(start+1)
    setTimeout(function(){
      try{ var nb=getNextBtn(); if (nb && nb.click) nb.click(); }catch(_){}
    }, 60);
    setTimeout(function(){
      try{ if (typeof window.goNext==='function') window.goNext(); }catch(_){}
      try{ if (typeof window.nextQuestion==='function') window.nextQuestion(); }catch(_){}
    }, 140);
    setTimeout(function(){
      try{
        if (typeof window.showQuestion==='function' && Number(window.currentQuestion||0)===startIdx){
          window.showQuestion(startIdx+1);
        }
      }catch(_){}
    }, 260);
  }

  function onKeydownCapture(e){
    try{
      if (!e || e.key!=='Enter') return;
      var t=e.target||e.srcElement; if (!t || t.id!=='scoreInput') return;
      var i=cur(); if (!isNotable(i)) return;
      var v=readVal();
      if (isValid(v)){
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
        if (e.preventDefault) e.preventDefault();
        e.cancelBubble=true; e.returnValue=false;
        var start = i;
        advanceFlow(v, start);
      }
    }catch(_){}
  }
  function onClickCapture(e){
    try{
      var t=e.target||e.srcElement; if (!t) return;
      var id=t.id||''; if (id!=='validateScoreBtn' && id!=='okBtn') return;
      var i=cur(); if (!isNotable(i)) return;
      var v=readVal();
      if (isValid(v)){
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
        if (e.preventDefault) e.preventDefault();
        e.cancelBubble=true; e.returnValue=false;
        var start = i;
        advanceFlow(v, start);
      }
    }catch(_){}
  }

  function attach(){
    if (!window.__ensCapKD){ window.addEventListener('keydown', onKeydownCapture, true); window.__ensCapKD=true; }
    if (!window.__ensCapCL){ window.addEventListener('click', onClickCapture, true); window.__ensCapCL=true; }
  }
  attach();
  try{
    if (typeof window.showQuestion==='function' && !window.showQuestion.__ensWrap){
      var _orig=window.showQuestion;
      window.showQuestion=function(){
        var r=_orig.apply(this, arguments);
        try{ attach(); }catch(_){}
        return r;
      };
      window.showQuestion.__ensWrap=true;
    }
  }catch(_){}
})();
</script>





<!-- SKIP-ON-1 for selected NOTABLES: jump to NEXT SECTION (not just next question) -->
<script type="text/javascript">
(function(){
  // Configure: list of 0-based question indices where entering "1" should skip to next section
  // User wants Q12 and Q21 to skip → indices 11 and 20
  window.SKIP_ON_ONE = (window.SKIP_ON_ONE || []).concat([11, 20]);

  function isNotable(i){
    i = Number(i);
    var L = window.NOTABLES || [];
    for (var k=0;k<L.length;k++){ if (L[k] === i) return true; }
    return false;
  }
  function cur(){ return Number(window.currentQuestion || 0); }
  function isSkipOnOne(i){
    var L = window.SKIP_ON_ONE || [];
    for (var k=0;k<L.length;k++){ if (L[k] === i) return true; }
    return false;
  }
  function getQuestions(){ return (typeof window.questions!=="undefined" && window.questions) ? window.questions : []; }
  function findNextSectionStart(fromIdx){
    try{
      var Q = getQuestions();
      if (!Q || !Q.length) return fromIdx+1;
      var s = (Q[fromIdx] && typeof Q[fromIdx].section!=="undefined") ? Q[fromIdx].section : null;
      // find the first j>fromIdx with section > s
      for (var j=fromIdx+1;j<Q.length;j++){
        var sj = (Q[j] && typeof Q[j].section!=="undefined") ? Q[j].section : null;
        if (s===null){ if (sj!==null) return j; }
        else if (sj!==null && sj > s){ return j; }
      }
      // if none, go to summary/end
      return Q.length; // will naturally fall through to summary in most flows
    }catch(_){ return fromIdx+1; }
  }

  // Core jump function
  function jumpToNextSection(startIdx){
    var target = findNextSectionStart(startIdx);
    // Try robust navigation
    try{
      if (typeof window.showQuestion === "function"){
        window.showQuestion(target);
        return;
      }
    }catch(_){}
    // Fallback: simulate multiple "next" until we cross a section boundary
    var tries = 0;
    var startSection = (getQuestions()[startIdx]||{}).section;
    (function tick(){
      tries++;
      try{ if (typeof window.goNext === "function") window.goNext(); }catch(_){}
      try{ if (typeof window.nextQuestion === "function") window.nextQuestion(); }catch(_){}
      setTimeout(function(){
        var cq = cur();
        var cs = (getQuestions()[cq]||{}).section;
        if ((cs!==startSection) || cq>=target || tries>15) return;
        tick();
      }, 60);
    })();
  }

  // Hook our existing robust submit path to branch on "1" for skip-list questions
  function readVal(){
    var si=document.getElementById('scoreInput'); if (!si) return NaN;
    var raw=(si.value||'').trim();
    var n=parseInt(raw,10);
    if (String(n)!==raw && !/^([1-5])$/.test(raw)) return NaN;
    return n;
  }
  function isValid(n){ return typeof n==='number' && n>=1 && n<=5 && Math.floor(n)===n; }

  function onKeydownCapture(e){
    try{
      if (!e || e.key!=='Enter') return;
      var t=e.target||e.srcElement; if (!t || t.id!=='scoreInput') return;
      var i=cur(); if (!isNotable(i)) return;
      var v=readVal();
      if (!isValid(v)) return;
      if (v===1 && isSkipOnOne(i)){
        // prevent normal flow and jump to next section
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
        if (e.preventDefault) e.preventDefault();
        e.cancelBubble=true; e.returnValue=false;
        // Clear field then jump
        try{ t.value=""; }catch(_){}
        jumpToNextSection(i);
      }
      // else: let the existing handlers (already in file) advance normally
    }catch(_){}
  }
  function onClickCapture(e){
    try{
      var t=e.target||e.srcElement; if (!t) return;
      var id=t.id||''; if (id!=='validateScoreBtn' && id!=='okBtn') return;
      var i=cur(); if (!isNotable(i)) return;
      var v=readVal();
      if (v===1 && isSkipOnOne(i)){
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
        if (e.preventDefault) e.preventDefault();
        e.cancelBubble=true; e.returnValue=false;
        var si=document.getElementById('scoreInput'); if (si){ try{ si.value=''; }catch(_){ } }
        jumpToNextSection(i);
      }
    }catch(_){}
  }

  // Attach high-priority capture listeners so we intercept before default submit
  if (!window.__skipOnOneKD){ window.addEventListener('keydown', onKeydownCapture, true); window.__skipOnOneKD=true; }
  if (!window.__skipOnOneCL){ window.addEventListener('click', onClickCapture, true); window.__skipOnOneCL=true; }

  // Re-attach after every showQuestion
  try{
    if (typeof window.showQuestion==='function' && !window.showQuestion.__skipOnOneWrap){
      var _orig = window.showQuestion;
      window.showQuestion = function(){
        var r = _orig.apply(this, arguments);
        try{
          if (!window.__skipOnOneKD){ window.addEventListener('keydown', onKeydownCapture, true); window.__skipOnOneKD=true; }
          if (!window.__skipOnOneCL){ window.addEventListener('click', onClickCapture, true); window.__skipOnOneCL=true; }
        }catch(_){}
        return r;
      };
      window.showQuestion.__skipOnOneWrap = true;
    }
  }catch(_){}
})();
</script>





<!-- FINAL OVERRIDE: SKIP-on-1 with explicit targets (ES5) -->
<script type="text/javascript">
(function(){
  // Explicit jump targets (0-based): Q12->Q14, Q21->Q23
  var SKIP_TARGETS = { 11: 13, 20: 22 }; // 11=Q12, 13=Q14 ; 20=Q21, 22=Q23

  // Make sure our skip list includes these indices
  window.SKIP_ON_ONE = window.SKIP_ON_ONE || [];
  for (var k in SKIP_TARGETS){
    if (Object.prototype.hasOwnProperty.call(SKIP_TARGETS,k)){
      var v = Number(k);
      var present = false;
      for (var i=0;i<window.SKIP_ON_ONE.length;i++){ if (window.SKIP_ON_ONE[i]===v){ present=true; break; } }
      if (!present) window.SKIP_ON_ONE.push(v);
    }
  }

  function cur(){ return Number(window.currentQuestion || 0); }
  function isSkipOnOne(i){
    var L = window.SKIP_ON_ONE || [];
    for (var m=0;m<L.length;m++){ if (L[m]===i) return true; }
    return false;
  }

  function jumpDirect(target){
    // Primary: direct showQuestion(target)
    try{ if (typeof window.showQuestion==='function'){ window.showQuestion(target); return true; } }catch(_){}
    // Fallback: simulate next until reach target
    var tries = 0;
    (function tick(){
      tries++;
      try{ if (typeof window.goNext==='function') window.goNext(); }catch(_){}
      try{ if (typeof window.nextQuestion==='function') window.nextQuestion(); }catch(_){}
      setTimeout(function(){
        var cq = cur();
        if (cq>=target || tries>20) return;
        tick();
      }, 50);
    })();
    return false;
  }

  function handleSkipOnOne(e){
    try{
      var i = cur();
      if (!isSkipOnOne(i)) return false;

      // read value safely
      var si = document.getElementById('scoreInput');
      var raw = si && si.value ? (""+si.value).trim() : "";
      if (raw !== "1") return false; // only act on exact "1"

      // prevent normal validation/advance
      if (e){
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
        if (e.preventDefault) e.preventDefault();
        e.cancelBubble = true; e.returnValue = false;
      }

      // clear field
      try{ if (si){ si.value=""; } }catch(_){}

      var target = (SKIP_TARGETS.hasOwnProperty(i) ? SKIP_TARGETS[i] : (i+1));
      // perform direct jump (with small reinforcements)
      jumpDirect(target);
      setTimeout(function(){ jumpDirect(target); }, 80);
      setTimeout(function(){ jumpDirect(target); }, 160);
      return true;
    }catch(_){ return false; }
  }

  function onKeydownCapture(e){
    try{
      if (!e || e.key!=='Enter') return;
      var t=e.target||e.srcElement; if (!t || t.id!=='scoreInput') return;
      handleSkipOnOne(e);
    }catch(_){}
  }
  function onClickCapture(e){
    try{
      var t=e.target||e.srcElement; if (!t) return;
      var id=t.id||''; if (id!=='validateScoreBtn' && id!=='okBtn') return;
      handleSkipOnOne(e);
    }catch(_){}
  }

  // Install capture listeners (last-word override)
  if (!window.__skipOneFinalKD){ window.addEventListener('keydown', onKeydownCapture, true); window.__skipOneFinalKD=true; }
  if (!window.__skipOneFinalCL){ window.addEventListener('click', onClickCapture, true); window.__skipOneFinalCL=true; }

  // After each navigation, reassert
  try{
    if (typeof window.showQuestion==='function' && !window.showQuestion.__skipOneFinalWrap){
      var _orig = window.showQuestion;
      window.showQuestion = function(){
        var r = _orig.apply(this, arguments);
        try{
          if (!window.__skipOneFinalKD){ window.addEventListener('keydown', onKeydownCapture, true); window.__skipOneFinalKD=true; }
          if (!window.__skipOneFinalCL){ window.addEventListener('click', onClickCapture, true); window.__skipOneFinalCL=true; }
        }catch(_){}
        return r;
      };
      window.showQuestion.__skipOneFinalWrap = true;
    }
  }catch(_){}
})();
</script>





<!-- ULTRA-ROBUST SKIP-on-1 to NEXT SECTION for Q12 and Q21 (ES5) -->
<script type="text/javascript">
(function(){
  // Explicit jump targets (0-based): Q12->Q14, Q21->Q23
  var SKIP_TARGETS = { 11: 13, 20: 22 }; // indexes: 11=Q12, 13=Q14 ; 20=Q21, 22=Q23

  function cur(){ return Number(window.currentQuestion || 0); }

  function forceJump(target){
    var start = cur();
    var tries = 0;
    var stopAt = Date.now ? Date.now() + 2000 : 0; // up to ~2s
    (function tick(){
      tries++;
      try{ if (typeof window.showQuestion === 'function') window.showQuestion(target); }catch(_){}
      try{ if (typeof window.goToSection === 'function') window.goToSection(target); }catch(_){}
      try{ if (typeof window.navigateToSection === 'function') window.navigateToSection(target); }catch(_){}
      try{ if (typeof window.goNext === 'function' && cur() < target) window.goNext(); }catch(_){}
      try{ if (typeof window.nextQuestion === 'function' && cur() < target) window.nextQuestion(); }catch(_){}
      // Also click any Next/Continue button we can find
      try{
        var ids = ['nextBtn','continueBtn','validerBtn','validateBtn'];
        for (var k=0;k<ids.length;k++){
          var b = document.getElementById(ids[k]);
          if (b && b.click) b.click();
        }
      }catch(_){}
      // Check if we reached or passed the target, or timed out
      setTimeout(function(){
        var ok = (cur() >= target);
        var timeout = (stopAt && (Date.now() > stopAt));
        if (!ok && !timeout && tries < 40){ tick(); }
      }, 50);
    })();
  }

  function handleSkipOnOne(e){
    try{
      var i = cur();
      if (!SKIP_TARGETS.hasOwnProperty(i)) return false;

      // read exact raw value
      var si = document.getElementById('scoreInput');
      var raw = si && si.value ? (""+si.value).trim() : "";
      if (raw !== "1") return false; // only act on exact "1"

      // prevent any normal submit/advance
      if (e){
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
        if (e.preventDefault) e.preventDefault();
        e.cancelBubble = true; e.returnValue = false;
      }

      // clear input and errors
      try{ if (si){ si.value=""; } }catch(_){}
      try{
        var ids = ["scoreError","errorScale","mainErrorMsg","errorLabel"];
        for (var z=0; z<ids.length; z++){
          var el = document.getElementById(ids[z]);
          if (el){ el.textContent = ""; el.innerHTML = ""; }
        }
      }catch(_){}

      var target = SKIP_TARGETS[i];
      // very robust: assert multiple times
      forceJump(target);
      setTimeout(function(){ forceJump(target); }, 120);
      setTimeout(function(){ forceJump(target); }, 240);
      return true;
    }catch(_){ return false; }
  }

  function onKeydownCapture(e){
    try{
      if (!e || e.key !== 'Enter') return;
      var t = e.target || e.srcElement; if (!t || t.id !== 'scoreInput') return;
      handleSkipOnOne(e);
    }catch(_){}
  }
  function onClickCapture(e){
    try{
      var t = e.target || e.srcElement; if (!t) return;
      var id = t.id || '';
      if (id === 'validateScoreBtn' || id === 'okBtn' || id === 'validerBtn' || id === 'validateBtn'){
        handleSkipOnOne(e);
      }
    }catch(_){}
  }

  // Install capture listeners with highest priority
  if (!window.__skipOneUltraKD){ window.addEventListener('keydown', onKeydownCapture, true); window.__skipOneUltraKD = true; }
  if (!window.__skipOneUltraCL){ window.addEventListener('click', onClickCapture, true); window.__skipOneUltraCL = true; }

  // Re-attach after navigation
  try{
    if (typeof window.showQuestion === 'function' && !window.showQuestion.__skipOneUltraWrap){
      var _orig = window.showQuestion;
      window.showQuestion = function(){
        var r = _orig.apply(this, arguments);
        try{
          if (!window.__skipOneUltraKD){ window.addEventListener('keydown', onKeydownCapture, true); window.__skipOneUltraKD = true; }
          if (!window.__skipOneUltraCL){ window.addEventListener('click', onClickCapture, true); window.__skipOneUltraCL = true; }
        }catch(_){}
        return r;
      };
      window.showQuestion.__skipOneUltraWrap = true;
    }
  }catch(_){}
})();
</script>


</body>
</html>